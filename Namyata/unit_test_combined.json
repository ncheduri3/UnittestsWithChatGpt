{"schema":{"fields":[{"name":"function_name","type":"string"},{"name":"header","type":"string"},{"name":"docstr","type":"string"},{"name":"code","type":"string"},{"name":"test","type":"string"}],"pandas_version":"1.4.0"},"data":[{"function_name":"arrangeCoins","header":"def arrangeCoins(n: int) -> int:\n","docstr":" You have n coins and you want to build a staircase with these coins. The staircase consists of k rows where the ith row has exactly i coins. The last row of the staircase may be incomplete.\n\n Given the integer n, return the number of complete rows of the staircase you will build.\n\n Constraints:\n\n 1 <= n <= 231 - 1\n","code":"    return int(sqrt(2 * n + 0.25) - 0.50)\n","test":"    def test_5_coins(self):\n        n = 5\n        expected = 2\n        self.assertEqual(arrangeCoins(n), expected)\n\n    def test_8_coins(self):\n        n = 8\n        expected = 3\n        self.assertEqual(arrangeCoins(n), expected)\n\n    def test_10_coins(self):\n        n = 10\n        expected = 4\n        self.assertEqual(arrangeCoins(n), expected)\n\n    def test_0_coins(self):\n        n = 0\n        expected = 0\n        self.assertEqual(arrangeCoins(n), expected)\n\n    def test_large_number_of_coins(self):\n        n = 1000000\n        expected = 1414\n        # expected = 1413\n        self.assertEqual(arrangeCoins(n), expected)\n"},{"function_name":"findDelayedArrivalTime","header":"def findDelayedArrivalTime( arrivalTime: int, delayedTime: int) -> int:\n","docstr":"","code":"    return (arrivalTime + delayedTime) % 24\n","test":"    def test_find_delayed_arrival_time(self):\n    # Replace YourClass with the actual class name\n\n        # Test Case 1\n        self.assertEqual(findDelayedArrivalTime(10, 5), 15)\n\n        # Test Case 2\n        self.assertEqual(findDelayedArrivalTime(20, 8), 4)\n\n        # Test Case 3\n        self.assertEqual(findDelayedArrivalTime(5, 20), 1)\n\n        # Test Case 4\n        self.assertEqual(findDelayedArrivalTime(15, 0), 15)\n\n        # Test Case 5\n        self.assertEqual(findDelayedArrivalTime(23, 3), 2)\n"},{"function_name":"findContentChildren","header":"def findContentChildren(g: List[int], s: List[int]) -> int:\n","docstr":" Assume you are an awesome parent and want to give your children some cookies. But, you should give each child at most one cookie.\n\n Each child i has a greed factor g[i], which is the minimum size of a cookie that the child will be content with;\n and each cookie j has a size s[j]. If s[j] >= g[i], we can assign the cookie j to the child i,\n and the child i will be content. Your goal is to maximize the number of your content children and output the maximum number.\n\n Constraints:\n\n 1 <= g.length <= 3 * 104\n 0 <= s.length <= 3 * 104\n 1 <= g[i], s[j] <= 231 - 1\n","code":"    g.sort()\n    s.sort()\n\n    ind = len(s) - 1\n    res = 0\n\n    for i in range(len(g) - 1, -1, -1):\n        if ind >= 0 and g[i] <= s[ind]:\n            res += 1\n            ind -= 1\n\n    return res\n","test":"    def test_equal_sizes(self):\n        g = [1, 2, 3]\n        s = [1, 2, 3]\n        expected = 3\n        self.assertEqual(findContentChildren(g, s), expected)\n\n    def test_more_cookies_than_children(self):\n        g = [1, 2, 3]\n        s = [1, 2, 3, 4, 5]\n        expected = 3\n        self.assertEqual(findContentChildren(g, s), expected)\n\n    def test_more_children_than_cookies(self):\n        g = [1, 2, 3, 4, 5]\n        s = [1, 2, 3]\n        expected = 3\n        self.assertEqual(findContentChildren(g, s), expected)\n\n    def test_no_cookies(self):\n        g = [1, 2, 3]\n        s = []\n        expected = 0\n        self.assertEqual(findContentChildren(g, s), expected)\n\n    def test_no_children(self):\n        g = []\n        s = [1, 2, 3]\n        expected = 0\n        self.assertEqual(findContentChildren(g, s), expected)\n\n    def test_empty_lists(self):\n        g = []\n        s = []\n        expected = 0\n        self.assertEqual(findContentChildren(g, s), expected)\n"},{"function_name":"some_function","header":"def some_function( salary) -> float:\n","docstr":" You are given an array of unique integers salary where salary[i] is the salary of the ith employee.\n\n Return the average salary of employees excluding the minimum and maximum salary.\n Answers within 10-5 of the actual answer will be accepted\n","code":"    salary.sort()\n    sum = 0\n    for s in salary:\n        sum += s\n    return (sum - salary[0] - salary[-1]) \/ (len(salary) - 2)\n","test":"    #corrected test cases\n    def test_some_function(self):\n          # Replace YourClass with the actual class name\n\n        # Test Case 1\n        salary = [1000, 2000, 3000, 4000, 5000]\n        self.assertAlmostEqual(some_function(salary), 3000.0)\n\n        # Test Case 2\n        salary = [500, 800, 1200, 1500]\n        self.assertAlmostEqual(some_function(salary), 1000.0)\n\n        # Test Case 3\n        salary = [2500, 3500, 2000, 4500]\n        self.assertAlmostEqual(some_function(salary), 3000.0)\n\n        # Test Case 4\n        salary = [10000, 15000, 12000, 9000, 18000]\n        self.assertAlmostEqual(some_function(salary), 12333.333333333334)\n\n        # Test Case 5\n        salary = [5000, 3000, 2000, 4000, 6000, 1000]\n        self.assertAlmostEqual(some_function(salary), 3500.0)\n\n    def test_some_function_chat_gpt(self):\n          # Replace YourClass with the actual class name\n\n        # Test Case 1\n        salary = [1000, 2000, 3000, 4000, 5000]\n        self.assertAlmostEqual(some_function(salary), 3000.0)\n\n        # Test Case 2\n        salary = [500, 800, 1200, 1500]\n        self.assertAlmostEqual(some_function(salary), 900.0)\n\n        # Test Case 3\n        salary = [2500, 3500, 2000, 4500]\n        self.assertAlmostEqual(some_function(salary), 3000.0)\n\n        # Test Case 4\n        salary = [10000, 15000, 12000, 9000, 18000]\n        self.assertAlmostEqual(some_function(salary), 13000.0)\n\n        # Test Case 5\n        salary = [5000, 3000, 2000, 4000, 6000, 1000]\n        self.assertAlmostEqual(some_function(salary), 3500.0)\n"},{"function_name":"binaryGap","header":"def binaryGap(n: int) -> int:\n","docstr":" Given a positive integer n, find and return the longest distance between any two adjacent 1's in the binary representation of n. If there are no two adjacent 1's, return 0.\n\n Two 1's are adjacent if there are only 0's separating them (possibly no 0's). The distance between two 1's is the absolute difference between their bit positions. For example, the two 1's in \"1001\" have a distance of 3.\n","code":"    s = f'{n:b}'\n    result = 0\n    for i in range(len(s)):\n        if s[i] == '0':\n            continue\n        for j in range(i + 1, len(s)):\n            if s[j] == '0':\n                continue\n            result = max(result, j - i)\n            break\n    return result\n","test":"    def test_binary_gap(self):\n        n = 22\n        result = binaryGap(n)\n        self.assertEqual(result, 2)\n\n    def test_no_binary_gap(self):\n        n = 8\n        result = binaryGap(n)\n        self.assertEqual(result, 0)\n\n    def test_multiple_binary_gaps(self):\n        n = 37\n        result = binaryGap(n)\n        self.assertEqual(result, 2) # Comment This line and uncomment the next one\n        # self.assertEqual(result, 3)\n\n    def test_single_bit(self):\n        n = 1\n        result = binaryGap(n)\n        self.assertEqual(result, 0)\n\n    def test_maximum_binary_gap(self):\n        n = 5\n        result = binaryGap(n)\n        self.assertEqual(result, 1) # Uncomment the next line and comment this one\n        # self.assertEqual(result, 2)\n"},{"function_name":"containsDuplicate","header":"def containsDuplicate(nums):\n","docstr":"","code":"    return len(set(nums)) != len(nums)\n","test":"    def test_duplicates_present(self):\n        nums = [1, 2, 3, 1]\n        self.assertTrue(containsDuplicate(nums))\n\n    def test_no_duplicates(self):\n        nums = [1, 2, 3, 4]\n        self.assertFalse(containsDuplicate(nums))\n\n    def test_empty_array(self):\n        nums = []\n        self.assertFalse(containsDuplicate(nums))\n\n    def test_single_element_array(self):\n        nums = [5]\n        self.assertFalse(containsDuplicate(nums))\n\n    def test_duplicates_with_negative_numbers(self):\n        nums = [-1, 2, -1, 4]\n        self.assertTrue(containsDuplicate(nums))\n"},{"function_name":"isAnagram","header":"def isAnagram(s, t):\n","docstr":" Given two strings s and t, return true if t is an anagram of s, and false otherwise.\n\n An Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.\n\n","code":"    if len(s) != len(t):\n        return False\n    for idx in set(s):\n        if s.count(idx) != t.count(idx):\n            return False\n    return True\n","test":"    def test_anagram_strings(self):\n        s = \"listen\"\n        t = \"silent\"\n        self.assertTrue(isAnagram(s, t))\n\n    def test_non_anagram_strings(self):\n        s = \"hello\"\n        t = \"world\"\n        self.assertFalse(isAnagram(s, t))\n\n    def test_anagram_with_duplicate_characters(self):\n        s = \"anagram\"\n        t = \"nagaram\"\n        self.assertTrue(isAnagram(s, t))\n\n    def test_different_length_strings(self):\n        s = \"cat\"\n        t = \"cats\"\n        self.assertFalse(isAnagram(s, t))\n\n    def test_empty_strings(self):\n        s = \"\"\n        t = \"\"\n        self.assertTrue(isAnagram(s, t))\n"},{"function_name":"numUniqueEmails","header":"def numUniqueEmails(emails: List[str]) -> int:\n","docstr":" Every valid email consists of a local name and a domain name, separated by the '@' sign. Besides lowercase letters, the email may contain one or more '.' or '+'.\n\n For example, in \"alice@leetcode.com\", \"alice\" is the local name, and \"leetcode.com\" is the domain name.\n If you add periods '.' between some characters in the local name part of an email address, mail sent there will be forwarded to the same address without dots in the local name. Note that this rule does not apply to domain names.\n\n For example, \"alice.z@leetcode.com\" and \"alicez@leetcode.com\" forward to the same email address.\n If you add a plus '+' in the local name, everything after the first plus sign will be ignored. This allows certain emails to be filtered. Note that this rule does not apply to domain names.\n\n For example, \"m.y+name@email.com\" will be forwarded to \"my@email.com\".\n It is possible to use both of these rules at the same time.\n\n Given an array of strings emails where we send one email to each emails[i], return the number of different addresses that actually receive mails.\n","code":"    set_ = set()\n    for i in emails:\n        final_email = \"\"\n        email = i.split(\"@\")\n        email[0] = email[0].replace(\".\", \"\")\n        if \"+\" in email[0]:\n            index = email[0].index(\"+\")\n            email[0] = email[0][:index]\n        final_email += email[0] + \"@\" + email[1]\n        set_.add(final_email)\n    return len(set_)\n","test":"    def test_empty_list(self):\n        emails = []\n        expected = 0\n        self.assertEqual(numUniqueEmails(emails), expected)\n\n    def test_single_email(self):\n        emails = [\"test.email@example.com\"]\n        expected = 1\n        self.assertEqual(numUniqueEmails(emails), expected)\n\n    def test_duplicate_emails(self):\n        emails = [\"test.email@example.com\", \"test.email@example.com\"]\n        expected = 1\n        self.assertEqual(numUniqueEmails(emails), expected)\n\n    def test_unique_emails(self):\n        emails = [\"test.email@example.com\", \"test.email2@example.com\", \"another.email@example.com\"]\n        expected = 3\n        self.assertEqual(numUniqueEmails(emails), expected)\n\n    def test_emails_with_dots(self):\n        emails = [\"t.est.email@example.com\", \"testemail@example.com\"]\n        expected = 1\n        self.assertEqual(numUniqueEmails(emails), expected)\n\n    def test_emails_with_plus(self):\n        emails = [\"test.email+spam@example.com\", \"test.email@example.com\"]\n        expected = 1\n        self.assertEqual(numUniqueEmails(emails), expected)\n\n    def test_emails_with_com_suffix(self):\n        emails = [\"test.email@example.com\", \"test.email@example.org\"]\n        expected = 2\n        self.assertEqual(numUniqueEmails(emails), expected)\n"},{"function_name":"isHappy","header":"def isHappy(n: int) -> bool:\n","docstr":" Write an algorithm to determine if a number n is happy.\n\n A happy number is a number defined by the following process:\n\n Starting with any positive integer, replace the number by the sum of the squares of its digits.\n Repeat the process until the number equals 1 (where it will stay), or it loops endlessly in a cycle which does not include 1.\n Those numbers for which this process ends in 1 are happy.\n Return true if n is a happy number, and false if not.\n","code":"    visited = set()  # set to keep track of visited numbers\n\n    while n != 1:  # continue loop until happy or stuck in cycle\n        sum_of_squares = 0\n\n        # compute sum of squares of digits in n\n        while n > 0:\n            digit = n % 10\n            sum_of_squares += digit ** 2\n            n \/\/= 10\n\n        # check if sum is already visited\n        if sum_of_squares in visited:\n            return False\n\n        # add sum to visited set\n        visited.add(sum_of_squares)\n\n        # set n to be the sum of squares for the next iteration\n        n = sum_of_squares\n\n    return True\n","test":"    def test_happy_number(self):\n        n = 19\n        expected = True\n        self.assertEqual(isHappy(n), expected)\n\n    def test_unhappy_number(self):\n        n = 20\n        expected = False\n        self.assertEqual(isHappy(n), expected)\n\n    def test_zero(self):\n        n = 0\n        expected = False\n        self.assertEqual(isHappy(n), expected)\n\n    def test_single_digit_happy_number(self):\n        n = 7\n        expected = True\n        self.assertEqual(isHappy(n), expected)\n\n    def test_single_digit_unhappy_number(self):\n        n = 4\n        expected = False\n        self.assertEqual(isHappy(n), expected)\n"},{"function_name":"isMonotonic","header":"def isMonotonic(nums: List[int]) -> bool:\n","docstr":" An array is monotonic if it is either monotone increasing or monotone decreasing.\n\n An array nums is monotone increasing if for all i <= j, nums[i] <= nums[j]. An array nums is monotone decreasing if for all i <= j, nums[i] >= nums[j].\n\n Given an integer array nums, return true if the given array is monotonic, or false otherwise.\n","code":"    return nums == sorted(nums) or nums == sorted(nums, reverse=True)\n","test":"    def test_increasing_list(self):\n        nums = [1, 2, 3, 4, 5]\n        expected = True\n        self.assertEqual(isMonotonic(nums), expected)\n\n    def test_decreasing_list(self):\n        nums = [5, 4, 3, 2, 1]\n        expected = True\n        self.assertEqual(isMonotonic(nums), expected)\n\n    def test_monotonic_list(self):\n        nums = [1, 3, 5, 7, 9]\n        expected = True\n        self.assertEqual(isMonotonic(nums), expected)\n\n    def test_non_monotonic_list(self):\n        nums = [1, 3, 2, 5, 4]\n        expected = False\n        self.assertEqual(isMonotonic(nums), expected)\n\n    def test_equal_elements_list(self):\n        nums = [5, 5, 5, 5, 5]\n        expected = True\n        self.assertEqual(isMonotonic(nums), expected)\n"},{"function_name":"checkStraightLine","header":"def checkStraightLine(coordinates):\n","docstr":" You are given an array coordinates, coordinates[i] = [x, y], where [x, y] represents\n the coordinate of a point. Check if these points make a straight line in the XY plane.\n","code":"    x0, y0 = coordinates[0]\n    x1, y1 = coordinates[1]\n\n    for i in range(2, len(coordinates)):\n        x, y = coordinates[i]\n        if (x - x0) * (y1 - y0) != (y - y0) * (x1 - x0):\n            return False\n\n    return True\n","test":"    def test_straight_line(self):\n        coordinates = [[1, 2], [2, 3], [3, 4], [4, 5], [5, 6]]\n        self.assertTrue(checkStraightLine(coordinates))\n\n    def test_not_straight_line(self):\n        coordinates = [[1, 2], [2, 3], [3, 4], [4, 5], [5, 7]]\n        self.assertFalse(checkStraightLine(coordinates))\n\n    def test_collinear_points(self):\n        coordinates = [[0, 0], [1, 1], [2, 2], [3, 3], [4, 4]]\n        self.assertTrue(checkStraightLine(coordinates))\n\n    def test_vertical_line(self):\n        coordinates = [[1, 2], [1, 3], [1, 4], [1, 5], [1, 6]]\n        self.assertTrue(checkStraightLine(coordinates))\n\n    def test_horizontal_line(self):\n        coordinates = [[1, 1], [2, 1], [3, 1], [4, 1], [5, 1]]\n        self.assertTrue(checkStraightLine(coordinates))\n"},{"function_name":"detectCapitalUse","header":"def detectCapitalUse(word: str) -> bool:\n","docstr":" We define the usage of capitals in a word to be right when one of the following cases holds:\n\n All letters in this word are capitals, like \"USA\".\n All letters in this word are not capitals, like \"leetcode\".\n Only the first letter in this word is capital, like \"Google\".\n Given a string word, return true if the usage of capitals in it is right.\n","code":"    return True if word.islower() or word.istitle() or word.isupper() else False\n","test":"    def test_all_lower_case(self):\n        word = \"hello\"\n        expected = True\n        self.assertEqual(detectCapitalUse(word), expected)\n\n    def test_all_upper_case(self):\n        word = \"HELLO\"\n        expected = True\n        self.assertEqual(detectCapitalUse(word), expected)\n\n    def test_title_case(self):\n        word = \"Title\"\n        expected = True\n        self.assertEqual(detectCapitalUse(word), expected)\n\n    def test_mixed_case(self):\n        word = \"MiXeD\"\n        expected = False\n        self.assertEqual(detectCapitalUse(word), expected)\n\n    def test_single_letter(self):\n        word = \"A\"\n        expected = True\n        self.assertEqual(detectCapitalUse(word), expected)\n"},{"function_name":"countNegatives","header":"def countNegatives(grid: List[List[int]]) -> int:\n","docstr":" Given a m x n matrix grid which is sorted in non-increasing order both row-wise and column-wise,\n return the number of negative numbers in grid\n Constraints:\n\n m == grid.length\n n == grid[i].length\n 1 <= m, n <= 100\n -100 <= grid[i][j] <= 100\n","code":"    ROWS, COLS = len(grid), len(grid[0])\n    negatives = 0\n    col = 0\n    for row in range(ROWS - 1, -1, -1):\n        while col < COLS and grid[row][col] >= 0:\n            col += 1\n        negatives += COLS - col\n    return negatives\n","test":"    def test_no_negatives(self):\n        grid = [\n            [4, 3, 2],\n            [3, 2, 1],\n            [2, 1, 0]\n        ]\n        self.assertEqual(countNegatives(grid), 0)\n\n    def test_all_negatives(self):\n        grid = [\n            [-1, -2, -3],\n            [-4, -5, -6],\n            [-7, -8, -9]\n        ]\n        self.assertEqual(countNegatives(grid), 9)\n\n    def test_mixed_negatives(self):\n        grid = [\n            [4, 3, -2],\n            [3, -5, -6],\n            [-7, -8, -9]\n        ]\n        self.assertEqual(countNegatives(grid), 6)\n\n    def test_large_grid(self):\n        grid = [\n            [-1, -2, -3, -4, -5],\n            [-6, -7, -8, -9, -10],\n            [-11, -12, -13, -14, -15]\n        ]\n        self.assertEqual(countNegatives(grid), 15)\n"},{"function_name":"firstUniqChar","header":"def firstUniqChar(s: str) -> int:\n","docstr":" Given a string s, find the first non-repeating character in it and return its index. If it does not exist, return -1.\n\n Constraints:\n\n 1 <= s.length <= 105\n s consists of only lowercase English letters.\n","code":"    count = Counter(s)\n    for char, freq in count.items():\n        if freq == 1:\n            return s.index(char)\n    return -1\n","test":"    def test_no_uniq_char(self):\n        s = \"ababcc\"\n        expected = -1\n        self.assertEqual(firstUniqChar(s), expected)\n\n    def test_single_uniq_char(self):\n        s = \"leetcode\"\n        expected = 0\n        self.assertEqual(firstUniqChar(s), expected)\n\n    def test_multiple_uniq_chars(self):\n        s = \"loveleetcode\"\n        expected = 2\n        self.assertEqual(firstUniqChar(s), expected)\n\n    def test_all_uniq_chars(self):\n        s = \"abcd\"\n        expected = 0\n        self.assertEqual(firstUniqChar(s), expected)\n"},{"function_name":"generatePossibleNextMoves","header":"def generatePossibleNextMoves(currentState: str) :\n","docstr":" You are playing a Flip Game with your friend.\n\n You are given a string currentState that contains only '+' and '-'. You and your friend take turns to flip two consecutive \"++\" into \"--\". The game ends when a person can no longer make a move, and therefore the other person will be the winner.\n\n Return all possible states of the string currentState after one valid move. You may return the answer in any order. If there is no valid move, return an empty list [].\n \n Constraints:\n\n 1 <= currentState.length <= 500\n currentState[i] is either '+' or '-'.\n","code":"    if not \"++\" in currentState:\n        return []\n    splt = [_ for _ in currentState]\n    res = []\n    i = 0\n    while i <= len(currentState) - 2:\n        if currentState[i:(i + 2)] == \"++\":\n            tmp = splt.copy()\n            tmp[i], tmp[i + 1] = '--'\n            res.append(''.join(tmp))\n        i += 1\n    return res\n","test":"    def test_no_moves(self):\n        currentState = \"--\"\n        expected = []\n        self.assertEqual(generatePossibleNextMoves(currentState), expected)\n\n    def test_single_move(self):\n        currentState = \"++-+\"\n        expected = [\"--+\"]\n        # expected = [\"---+\"]\n        self.assertEqual(generatePossibleNextMoves(currentState), expected)\n\n    def test_multiple_moves(self):\n        currentState = \"++++\"\n        expected = [\"--++\", \"+--+\", \"++--\"]\n        self.assertEqual(generatePossibleNextMoves(currentState), expected)\n\n    def test_no_plus_signs(self):\n        currentState = \"--\"\n        expected = []\n        self.assertEqual(generatePossibleNextMoves(currentState), expected)\n"},{"function_name":"divisorGame","header":"def divisorGame(n: int) -> bool:\n","docstr":" Alice and Bob take turns playing a game, with Alice starting first.\n\n Initially, there is a number n on the chalkboard. On each player's turn, that player makes a move consisting of:\n\n Choosing any x with 0 < x < n and n % x == 0.\n Replacing the number n on the chalkboard with n - x.\n Also, if a player cannot make a move, they lose the game.\n\n Return true if and only if Alice wins the game, assuming both players play optimally.\n","code":"    return n % 2 == 0\n","test":"    def test_even_number(self):\n        n = 4\n        expected = True\n        self.assertEqual(divisorGame(n), expected)\n\n    def test_odd_number(self):\n        n = 7\n        expected = False\n        self.assertEqual(divisorGame(n), expected)\n\n    def test_zero(self):\n        n = 0\n        expected = True\n        self.assertEqual(divisorGame(n), expected)\n\n    def test_large_number(self):\n        n = 1000000\n        expected = True\n        self.assertEqual(divisorGame(n), expected)\n"},{"function_name":"numJewelsInStones","header":"def numJewelsInStones(jewels: str, stones: str) -> int:\n","docstr":" You're given strings jewels representing the types of stones that are jewels, and stones representing the stones you have. Each character in stones is a type of stone you have. You want to know how many of the stones you have are also jewels.\n\n Letters are case sensitive, so \"a\" is considered a different type of stone from \"A\".\n\n Constraints:\n\n 1 <= jewels.length, stones.length <= 50\n jewels and stones consist of only English letters.\n All the characters of jewels are unique.\n","code":"    counter = 0\n    for i in stones:\n        if i in jewels:\n            counter += 1\n    return counter\n","test":"    def test_all_jewels_in_stones(self):\n        jewels = \"abc\"\n        stones = \"aabbbccc\"\n        result = numJewelsInStones(jewels, stones)\n        self.assertEqual(result, 9) # Comment this and Uncomment the next line\n        # self.assertEqual(result, 10)\n\n    def test_no_jewels_in_stones(self):\n        jewels = \"abc\"\n        stones = \"def\"\n        result = numJewelsInStones(jewels, stones)\n        self.assertEqual(result, 0)\n\n    def test_some_jewels_in_stones(self):\n        jewels = \"abc\"\n        stones = \"aadefbcc\"\n        result = numJewelsInStones(jewels, stones)\n        self.assertEqual(result, 6) # Comment this and Uncomment the next line\n        self.assertEqual(result, 5)\n\n    def test_empty_stones(self):\n        jewels = \"abc\"\n        stones = \"\"\n        result = numJewelsInStones(jewels, stones)\n        self.assertEqual(result, 0)\n\n    def test_empty_jewels(self):\n        jewels = \"\"\n        stones = \"abcdef\"\n        result = numJewelsInStones(jewels, stones)\n        self.assertEqual(result, 0)\n"},{"function_name":"kItemsWithMaximumSum","header":"def kItemsWithMaximumSum( numOnes: int, numZeros: int, numNegOnes: int, k: int) -> int:\n","docstr":" Question :\n There is a bag that consists of items, each item has a number 1, 0, or -1 written on it.\n\n You are given four non-negative integers numOnes, numZeros, numNegOnes, and k.\n\n The bag initially contains:\n\n numOnes items with 1s written on them.\n numZeroes items with 0s written on them.\n numNegOnes items with -1s written on them.\n We want to pick exactly k items among the available items. Return the maximum possible sum of numbers written on the items.\n","code":"    return min((k, numOnes)) + (min((numNegOnes, k - numOnes - numZeros)) * -1 if (k - numOnes - numZeros) > 0 else 0)\n","test":"    def test_k_items_with_maximum_sum(self):\n         # Replace YourClass with the actual class name\n\n        # Test Case 1\n        self.assertEqual(kItemsWithMaximumSum(5, 3, 2, 4), 4)\n\n        # Test Case 2\n        self.assertEqual(kItemsWithMaximumSum(2, 4, 1, 3), 2)\n\n        # Test Case 3\n        self.assertEqual(kItemsWithMaximumSum(0, 0, 0, 2), 0)\n\n        # Test Case 4\n        self.assertEqual(kItemsWithMaximumSum(10, 5, 3, 10), 10)\n\n        # Test Case 5\n        self.assertEqual(kItemsWithMaximumSum(3, 2, 1, 6), 2)\n"},{"function_name":"kItemsWithMaximumSum","header":"def kItemsWithMaximumSum(numOnes: int, numZeros: int, numNegOnes: int, k: int) -> int:\n","docstr":"","code":"    ones_taken = min(k, numOnes)\n    remaining_k = k - ones_taken\n    neg_ones_taken = min(remaining_k, numNegOnes) * -1 if remaining_k > 0 else 0\n\n    return ones_taken + neg_ones_taken\n","test":"    def test_k_items_with_maximum_sum_corrected(self):\n        # Test Case 1\n        numOnes = 5\n        numZeros = 3\n        numNegOnes = 2\n        k = 4\n        self.assertEqual(kItemsWithMaximumSum(numOnes, numZeros, numNegOnes, k), 4)\n\n        # Test Case 2\n        numOnes = 2\n        numZeros = 4\n        numNegOnes = 1\n        k = 3\n        self.assertEqual(kItemsWithMaximumSum(numOnes, numZeros, numNegOnes, k), 1) # should have been 0 - missed case!!\n\n        # Test Case 3\n        numOnes = 0\n        numZeros = 0\n        numNegOnes = 0\n        k = 2\n        self.assertEqual(kItemsWithMaximumSum(numOnes, numZeros, numNegOnes, k), 0)\n\n        # Test Case 4\n        numOnes = 10\n        numZeros = 5\n        numNegOnes = 3\n        k = 10\n        self.assertEqual(kItemsWithMaximumSum(numOnes, numZeros, numNegOnes, k), 10)\n\n        # Test Case 5\n        numOnes = 3\n        numZeros = 2\n        numNegOnes = 1\n        k = 6\n        self.assertEqual(kItemsWithMaximumSum(numOnes, numZeros, numNegOnes, k), 2)\n"},{"function_name":"largestTriangleArea","header":"def largestTriangleArea(points: List[List[int]]) -> float:\n","docstr":" Given an array of points on the X-Y plane points where points[i] = [xi, yi],\n return the area of the largest triangle that can be formed by any three different points.\n Answers within 10-5 of the actual answer will be accepted.\n\n Constraints:\n\n 3 <= points.length <= 50\n -50 <= xi, yi <= 50\n All the given points are unique.\n","code":"    area = 0\n    n = len(points)\n    for i in range(n):\n        x1, y1 = points[i]\n        for j in range(i + 1, n):\n            x2, y2 = points[j]\n            for k in range(j + 1, n):\n                x3, y3 = points[k]\n                curr = abs(0.5 * (x1 * (y2 - y3) + x2 * (y3 - y1) + x3 * (y1 - y2)))\n                if curr > area:\n                    area = curr\n    return area\n","test":"    def test_valid_triangle_area(self):\n        points = [[0, 0], [0, 1], [1, 0]]\n        result = largestTriangleArea(points)\n        self.assertAlmostEqual(result, 0.5, places=6)\n\n    def test_zero_area(self):\n        points = [[0, 0], [0, 0], [0, 0]]\n        result = largestTriangleArea(points)\n        self.assertAlmostEqual(result, 0, places=6)\n\n    def test_large_triangle_area(self):\n        points = [[-50, -50], [0, 0], [50, -50], [0, 25]]\n        result = largestTriangleArea(points)\n        self.assertAlmostEqual(result, 1250, places=6) # comment this and uncomment the next line to run\n        # self.assertAlmostEqual(result, 3750, places=6)\n\n    def test_single_point(self):\n        points = [[0, 0]]\n        result = largestTriangleArea(points)\n        self.assertAlmostEqual(result, 0, places=6)\n\n    def test_minimum_points(self):\n        points = [[0, 0], [1, 1], [2, 2]]\n        result = largestTriangleArea(points)\n        self.assertAlmostEqual(result, 0, places=6)\n"},{"function_name":"lastStoneWeight","header":"def lastStoneWeight(stones: List[int]) -> int:\n","docstr":" You are given an array of integers stones where stones[i] is the weight of the ith stone.\n\n We are playing a game with the stones. On each turn, we choose the heaviest two stones and smash them together. Suppose the heaviest two stones have weights x and y with x <= y. The result of this smash is:\n\n If x == y, both stones are destroyed, and\n If x != y, the stone of weight x is destroyed, and the stone of weight y has new weight y - x.\n At the end of the game, there is at most one stone left.\n\n Return the weight of the last remaining stone. If there are no stones left, return 0.\n\n Constraints:\n\n 1 <= stones.length <= 30\n 1 <= stones[i] <= 1000\n","code":"    stones.sort()\n\n    while stones:\n        s1 = stones.pop()\n\n        if not stones:\n            return s1\n\n        s2 = stones.pop()\n\n        if s1 > s2:\n            insort_left(stones, s1 - s2)\n\n    return 0\n","test":"    def test_single_stone(self):\n        stones = [5]\n        expected = 5\n        self.assertEqual(lastStoneWeight(stones), expected)\n\n    def test_two_stones(self):\n        stones = [3, 7]\n        expected = 4\n        self.assertEqual(lastStoneWeight(stones), expected)\n\n    def test_multiple_stones(self):\n        stones = [2, 7, 4, 1, 8, 1]\n        expected = 1\n        self.assertEqual(lastStoneWeight(stones), expected)\n\n    def test_same_weight_stones(self):\n        stones = [5, 5, 5, 5]\n        expected = 0\n        self.assertEqual(lastStoneWeight(stones), expected)\n\n    def test_empty_list(self):\n        stones = []\n        expected = 0\n        self.assertEqual(lastStoneWeight(stones), expected)\n"},{"function_name":"longestCommonPrefix","header":"def longestCommonPrefix(strs):\n","docstr":" Write a function to find the longest common prefix string amongst an array of strings.\n\n If there is no common prefix, return an empty string \"\".\n","code":"    ans = \"\"\n    v = sorted(strs)\n    first = v[0]\n    last = v[-1]\n    for i in range(min(len(first), len(last))):\n        if first[i] != last[i]:\n            return ans\n        ans += first[i]\n    return ans\n","test":"    def test_common_prefix_present(self):\n        strs = [\"flower\", \"flow\", \"flight\"]\n        expected_output = \"fl\"\n        self.assertEqual(longestCommonPrefix(strs), expected_output)\n\n    def test_no_common_prefix(self):\n        strs = [\"dog\", \"racecar\", \"car\"]\n        expected_output = \"\"\n        self.assertEqual(longestCommonPrefix(strs), expected_output)\n\n    def test_empty_array(self):\n        strs = []\n        expected_output = \"\"\n        self.assertEqual(longestCommonPrefix(strs), expected_output)\n\n    def test_single_element_array(self):\n        strs = [\"apple\"]\n        expected_output = \"apple\"\n        self.assertEqual(longestCommonPrefix(strs), expected_output)\n\n    def test_common_prefix_with_empty_string(self):\n        strs = [\"apple\", \"\"]\n        expected_output = \"\"\n        self.assertEqual(longestCommonPrefix(strs), expected_output)\n"},{"function_name":"findLHS","header":"def findLHS(nums) -> int:\n","docstr":" We define a harmonious array as an array where the difference between its maximum value and its minimum value is exactly 1.\n\n Given an integer array nums, return the length of its longest harmonious subsequence among all its possible subsequences.\n\n A subsequence of array is a sequence that can be derived from the array by deleting some or no elements without changing the order of the remaining elements.\n","code":"    freq = {}\n    for num in nums:\n        freq[num] = freq.get(num, 0) + 1\n    max_length = 0\n    for num in freq:\n        if num + 1 in freq:\n            max_length = max(max_length, freq[num] + freq[num + 1])\n    return max_length\n","test":"    def test_example_case(self):\n        nums = [1, 3, 2, 2, 5, 2, 3, 7]\n        expected = 5\n        self.assertEqual(findLHS(nums), expected)\n\n    def test_empty_list(self):\n        nums = []\n        expected = 0\n        self.assertEqual(findLHS(nums), expected)\n\n    def test_single_element(self):\n        nums = [5]\n        expected = 0\n        self.assertEqual(findLHS(nums), expected)\n\n    def test_no_consecutive_elements(self):\n        nums = [1, 2, 3, 4, 5]\n        expected = 0\n        # expected = 2\n        self.assertEqual(findLHS(nums), expected)\n\n    def test_negative_numbers(self):\n        nums = [-1, -2, -2, -2, -3, -4, -5]\n        expected = 3\n        # expected = 4\n        self.assertEqual(findLHS(nums), expected)\n\n    def test_large_input(self):\n        nums = [10**9] * 10**4 + [0] * 10**4\n        expected = 10**4\n        # expected = 0\n        self.assertEqual(findLHS(nums), expected)\n"},{"function_name":"maxProfit","header":"def maxProfit(prices):\n","docstr":" You are given an array prices where prices[i] is the price of a given stock on the ith day.\n\n You want to maximize your profit by choosing a single day to buy one stock and choosing a different day in the future to sell that stock.\n\n Return the maximum profit you can achieve from this transaction. If you cannot achieve any profit, return 0.\n","code":"    left = 0  # Buy\n    right = 1  # Sell\n    max_profit = 0\n    while right < len(prices):\n        current_profit = prices[right] - prices[left]  # our current Profit\n        if prices[left] < prices[right]:\n            max_profit = max(current_profit, max_profit)\n        else:\n            left = right\n        right += 1\n    return max_profit\n","test":"    def test_profit_possible(self):\n        prices = [7, 1, 5, 3, 6, 4]\n        expected_output = 5\n        self.assertEqual(maxProfit(prices), expected_output)\n\n    def test_no_profit_possible(self):\n        prices = [7, 6, 4, 3, 1]\n        expected_output = 0\n        self.assertEqual(maxProfit(prices), expected_output)\n\n    def test_empty_array(self):\n        prices = []\n        expected_output = 0\n        self.assertEqual(maxProfit(prices), expected_output)\n\n    def test_single_element_array(self):\n        prices = [5]\n        expected_output = 0\n        self.assertEqual(maxProfit(prices), expected_output)\n\n    def test_constant_price(self):\n        prices = [3, 3, 3, 3, 3]\n        expected_output = 0\n        self.assertEqual(maxProfit(prices), expected_output)\n"},{"function_name":"merge","header":"def merge(nums1, m, nums2, n):\n","docstr":" You are given two integer arrays nums1 and nums2, sorted in non-decreasing order, and two integers m and n, representing the number of elements in nums1 and nums2 respectively.\n\n Merge nums1 and nums2 into a single array sorted in non-decreasing order.\n\n The final sorted array should not be returned by the function, but instead be stored inside the array nums1. To accommodate this, nums1 has a length of m + n, where the first m elements denote the elements that should be merged, and the last n elements are set to 0 and should be ignored. nums2 has a length of n.\n\n","code":"    for i in range(m, m + n):\n        nums1[i] = nums2[i - m]\n    nums1.sort()\n","test":"    def test_merge_lists(self):\n        nums1 = [1, 2, 3, 0, 0, 0]\n        m = 3\n        nums2 = [2, 5, 6]\n        n = 3\n        merge(nums1, m, nums2, n)\n        expected_output = [1, 2, 2, 3, 5, 6]\n        self.assertEqual(nums1, expected_output)\n\n    def test_empty_list(self):\n        nums1 = []\n        m = 0\n        nums2 = []\n        n = 0\n        merge(nums1, m, nums2, n)\n        expected_output = []\n        self.assertEqual(nums1, expected_output)\n\n    def test_merge_into_empty_list(self):\n        nums1 = [0, 0, 0]\n        m = 0\n        nums2 = [1, 2, 3]\n        n = 3\n        merge(nums1, m, nums2, n)\n        expected_output = [1, 2, 3]\n        self.assertEqual(nums1, expected_output)\n\n    def test_merge_with_duplicate_elements(self):\n        nums1 = [1, 2, 3, 0, 0, 0]\n        m = 3\n        nums2 = [2, 2, 3]\n        n = 3\n        merge(nums1, m, nums2, n)\n        expected_output = [1, 2, 2, 2, 3, 3]\n        self.assertEqual(nums1, expected_output)\n\n    def test_merge_with_negative_numbers(self):\n        nums1 = [-1, 0, 0, 0]\n        m = 1\n        nums2 = [-2, -3, -4]\n        n = 3\n        merge(nums1, m, nums2, n)\n        expected_output = [-4, -3, -2, -1]\n        self.assertEqual(nums1, expected_output)\n"},{"function_name":"mergeTwoLists","header":"def mergeTwoLists(list1, list2):\n","docstr":" You are given the heads of two sorted linked lists list1 and list2.\n\n Merge the two lists in a one sorted list. The list should be made by splicing together the nodes of the first two lists.\n\n Return the head of the merged linked list.\n","code":"    head = ListNode()\n    current = head\n    while list1 and list2:\n        if list1.val < list2.val:\n            current.next = list1\n            list1 = list1.next\n        else:\n            current.next = list2\n            list2 = list2.next\n        current = current.next\n\n    current.next = list1 or list2\n    return head.next\n","test":"    def test_merge_lists(self):\n        # Create the input lists\n        # list1: 1 -> 2 -> 4\n        list1 = ListNode(1)\n        list1.next = ListNode(2)\n        list1.next.next = ListNode(4)\n\n        # list2: 1 -> 3 -> 4\n        list2 = ListNode(1)\n        list2.next = ListNode(3)\n        list2.next.next = ListNode(4)\n\n        # Expected merged list: 1 -> 1 -> 2 -> 3 -> 4 -> 4\n        expected_output = ListNode(1)\n        expected_output.next = ListNode(1)\n        expected_output.next.next = ListNode(2)\n        expected_output.next.next.next = ListNode(3)\n        expected_output.next.next.next.next = ListNode(4)\n        expected_output.next.next.next.next.next = ListNode(4)\n\n        finalList = mergeTwoLists(list1, list2)\n        fl = []\n        while finalList:\n            fl.append(finalList.val)\n            finalList = finalList.next\n        # Call the function and compare the output\n        self.assertEqual(fl, [1,1,2,3,4,4])\n\n    def test_empty_lists(self):\n        # Empty list1 and list2\n        list1 = None\n        list2 = None\n\n        # Merged list should be empty as well\n        expected_output = None\n\n        self.assertEqual(mergeTwoLists(list1, list2), expected_output)\n\n    def test_one_empty_list(self):\n        # list1: 1 -> 2 -> 3\n        list1 = ListNode(1)\n        list1.next = ListNode(2)\n        list1.next.next = ListNode(3)\n\n        # Empty list2\n        list2 = None\n\n        # Merged list should be list1 itself\n        expected_output = list1\n\n        self.assertEqual(mergeTwoLists(list1, list2), expected_output)\n\n    def test_same_values(self):\n        # list1: 1 -> 1 -> 1\n        list1 = ListNode(1)\n        list1.next = ListNode(1)\n        list1.next.next = ListNode(1)\n\n        # list2: 1 -> 1 -> 1\n        list2 = ListNode(1)\n        list2.next = ListNode(1)\n        list2.next.next = ListNode(1)\n\n        # Expected merged list: 1 -> 1 -> 1 -> 1 -> 1 -> 1\n        finalList = mergeTwoLists(list1, list2)\n        fl = []\n        while finalList:\n            fl.append(finalList.val)\n            finalList = finalList.next\n        self.assertEqual(fl, [1,1,1,1,1,1])\n\nclass MergeTwoListsTestCase(unittest.TestCase):\n    def test_merge_lists(self):\n        # Create the input lists\n        # list1: 1 -> 2 -> 4\n        list1 = ListNode(1)\n        list1.next = ListNode(2)\n        list1.next.next = ListNode(4)\n\n        # list2: 1 -> 3 -> 4\n        list2 = ListNode(1)\n        list2.next = ListNode(3)\n        list2.next.next = ListNode(4)\n\n        # Expected merged list: 1 -> 1 -> 2 -> 3 -> 4 -> 4\n        expected_output = ListNode(1)\n        expected_output.next = ListNode(1)\n        expected_output.next.next = ListNode(2)\n        expected_output.next.next.next = ListNode(3)\n        expected_output.next.next.next.next = ListNode(4)\n        expected_output.next.next.next.next.next = ListNode(4)\n\n        # Call the function and compare the output\n        self.assertEqual(mergeTwoLists(list1, list2), expected_output)\n\n    def test_empty_lists(self):\n        # Empty list1 and list2\n        list1 = None\n        list2 = None\n\n        # Merged list should be empty as well\n        expected_output = None\n\n        self.assertEqual(mergeTwoLists(list1, list2), expected_output)\n\n    def test_one_empty_list(self):\n        # list1: 1 -> 2 -> 3\n        list1 = ListNode(1)\n        list1.next = ListNode(2)\n        list1.next.next = ListNode(3)\n\n        # Empty list2\n        list2 = None\n\n        # Merged list should be list1 itself\n        expected_output = list1\n\n        self.assertEqual(mergeTwoLists(list1, list2), expected_output)\n\n    def test_same_values(self):\n        # list1: 1 -> 1 -> 1\n        list1 = ListNode(1)\n        list1.next = ListNode(1)\n        list1.next.next = ListNode(1)\n\n        # list2: 1 -> 1 -> 1\n        list2 = ListNode(1)\n        list2.next = ListNode(1)\n        list2.next.next = ListNode(1)\n\n        # Expected merged list: 1 -> 1 -> 1 -> 1 -> 1 -> 1\n        expected_output = ListNode(1)\n        expected_output.next = ListNode(1)\n        expected_output.next.next = ListNode(1)\n        expected_output.next.next.next = ListNode(1)\n        expected_output.next.next.next.next = ListNode(1)\n        expected_output.next.next.next.next.next = ListNode(1)\n\n        self.assertEqual(mergeTwoLists(list1, list2), expected_output)\n"},{"function_name":"findRestaurant","header":"def findRestaurant(list1, list2) :\n","docstr":" Given two arrays of strings list1 and list2, find the common strings with the least index sum.\n\n A common string is a string that appeared in both list1 and list2.\n\n A common string with the least index sum is a common string such that if it appeared at list1[i] and list2[j] then i + j should be the minimum value among all the other common strings.\n\n Return all the common strings with the least index sum. Return the answer in any order.\n","code":"    d = {}\n    for i in range(len(list1)):\n        for j in range(len(list2)):\n            if list1[i] == list2[j]:\n                d[list1[i]] = i + j\n    lst = []\n    for i, j in d.items():\n        if j == min(d.values()):\n            lst.append(i)\n    return lst\n","test":"    def test_example_case(self):\n        list1 = [\"Shogun\", \"Tapioca Express\", \"Burger King\", \"KFC\"]\n        list2 = [\"Piatti\", \"The Grill at Torrey Pines\", \"Hungry Hunter Steakhouse\", \"Shogun\"]\n        expected = [\"Shogun\"]\n        self.assertEqual(findRestaurant(list1, list2), expected)\n\n    def test_multiple_common_restaurants(self):\n        list1 = [\"KFC\", \"Burger King\", \"Pizza Hut\", \"McDonald's\"]\n        list2 = [\"Burger King\", \"Pizza Hut\", \"McDonald's\", \"KFC\"]\n        expected = [\"Burger King\"]\n        # expected = [\"Burger King\"]\n        self.assertEqual(findRestaurant(list1, list2), expected)\n\n    def test_no_common_restaurant(self):\n        list1 = [\"Subway\", \"Starbucks\", \"Chipotle\"]\n        list2 = [\"McDonald's\", \"Taco Bell\", \"Wendy's\"]\n        expected = []\n        self.assertEqual(findRestaurant(list1, list2), expected)\n\n    def test_empty_lists(self):\n        list1 = []\n        list2 = []\n        expected = []\n        self.assertEqual(findRestaurant(list1, list2), expected)\n\n    def test_large_input(self):\n        list1 = [\"Restaurant\" + str(i) for i in range(1000)]\n        list2 = [\"Cafe\" + str(i) for i in range(1000)]\n        expected = []\n        # expected = []\n        self.assertEqual(findRestaurant(list1, list2), expected)\n"},{"function_name":"moveZeroes","header":"def moveZeroes(nums) -> None:\n","docstr":" Given an integer array nums, move all 0's to the end of it while maintaining the relative order of the non-zero elements.\n\n Note that you must do this in-place without making a copy of the array.\n","code":"    \"\"\"\n    Do not return anything, modify nums in-place instead.\n    \"\"\"\n    slow = 0\n    for fast in range(len(nums)):\n        if nums[fast] != 0 and nums[slow] == 0:\n            nums[slow], nums[fast] = nums[fast], nums[slow]\n\n        # wait while we find a non-zero element to swap with you\n        if nums[slow] != 0:\n            slow += 1\n","test":"    def test_move_zeroes(self):\n        nums = [0, 1, 0, 3, 12]\n        expected = [1, 3, 12, 0, 0]\n        moveZeroes(nums)\n        self.assertEqual(nums, expected)\n\n    def test_no_zeroes(self):\n        nums = [1, 2, 3, 4, 5]\n        expected = [1, 2, 3, 4, 5]\n        moveZeroes(nums)\n        self.assertEqual(nums, expected)\n\n    def test_all_zeroes(self):\n        nums = [0, 0, 0, 0, 0]\n        expected = [0, 0, 0, 0, 0]\n        moveZeroes(nums)\n        self.assertEqual(nums, expected)\n\n    def test_mixed_elements(self):\n        nums = [0, 2, 0, 1, 0, 3, 0, 0, 12]\n        expected = [2, 1, 3, 12, 0, 0, 0, 0, 0]\n        moveZeroes(nums)\n        self.assertEqual(nums, expected)\n"},{"function_name":"findOcurrences","header":"def findOcurrences(text: str, first: str, second: str) -> List[str]:\n","docstr":" Given two strings first and second, consider occurrences in some text of the form \"first second third\",\n where second comes immediately after first, and third comes immediately after second.\n\n Return an array of all the words third for each occurrence of \"first second third\".\n","code":"    words = text.split()\n    thirds = []\n    for word in range(len(words) - 2):\n        if words[word] == first and words[word + 1] == second:\n            thirds.append(words[word + 2])\n    return thirds\n","test":"    def test_empty_text(self):\n        text = \"There\"\n        first = \"hello\"\n        second = \"world\"\n        expected = []\n        self.assertEqual(findOcurrences(text, first, second), expected)\n\n    def test_no_occurrences(self):\n        text = \"This is a sample sentence.\"\n        first = \"hello\"\n        second = \"world\"\n        expected = []\n        self.assertEqual(findOcurrences(text, first, second), expected)\n\n    def test_single_occurrence(self):\n        text = \"hello world hello there world\"\n        first = \"hello\"\n        second = \"world\"\n        expected = [\"hello\"]\n        self.assertEqual(findOcurrences(text, first, second), expected)\n\n    def test_multiple_occurrences(self):\n        text = \"hello world hello there world hello\"\n        first = \"hello\"\n        second = \"world\"\n        expected = [\"hello\"]\n        self.assertEqual(findOcurrences(text, first, second), expected)\n\n    def test_consecutive_occurrences(self):\n        text = \"hello world hello world hello\"\n        first = \"hello\"\n        second = \"world\"\n        expected = [\"hello\", \"hello\"]\n        self.assertEqual(findOcurrences(text, first, second), expected)\n\n    def test_long_text(self):\n        text = \"this is a long text with multiple occurrences of first and second words. first second first second first second.\"\n        first = \"first\"\n        second = \"second\"\n        expected = [\"first\", \"first\"]\n        self.assertEqual(findOcurrences(text, first, second), expected)\n"},{"function_name":"isPalindrome","header":"def isPalindrome(x):\n","docstr":" Given an integer x, return true if x is a\n palindrome\n , and false otherwise.\n","code":"    if x < 0:\n        return False\n\n    inputNum = x\n    newNum = 0\n    while x > 0:\n        newNum = newNum * 10 + x % 10\n        x = x \/\/ 10\n    return newNum == inputNum\n","test":"    def test_palindrome_number(self):\n        x = 121\n        self.assertTrue(isPalindrome(x))\n\n    def test_non_palindrome_number(self):\n        x = 123\n        self.assertFalse(isPalindrome(x))\n\n    def test_negative_number(self):\n        x = -121\n        self.assertFalse(isPalindrome(x))\n\n    def test_single_digit_number(self):\n        x = 5\n        self.assertTrue(isPalindrome(x))\n\n    def test_zero(self):\n        x = 0\n        self.assertTrue(isPalindrome(x))\n"},{"function_name":"check_is_prime","header":"def check_is_prime(n):\n","docstr":"","code":"    if n <= 1:\n        return False\n    for i in range(2, int(n**0.5) + 1):\n        if n % i == 0:\n            return False\n    return True\n","test":"    def test_prime_numbers(self):\n        primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29]\n        for prime in primes:\n            self.assertTrue(check_is_prime(prime), f\"{prime} should be prime\")\n\n    def test_non_prime_numbers(self):\n        non_primes = [1, 4, 6, 8, 9, 10, 12, 14, 15, 16, 18, 20]\n        for non_prime in non_primes:\n            self.assertFalse(check_is_prime(non_prime), f\"{non_prime} should not be prime\")\n\n    def test_negative_number(self):\n        negative_number = -7\n        self.assertFalse(check_is_prime(negative_number), f\"{negative_number} should not be prime\")\n\n    def test_zero(self):\n        zero = 0\n        self.assertFalse(check_is_prime(zero), f\"{zero} should not be prime\")\n\n    def test_one(self):\n        one = 1\n        self.assertFalse(check_is_prime(one), f\"{one} should not be prime\")\n"},{"function_name":"countPrimeSetBits","header":"def countPrimeSetBits(left: int, right: int) -> int:\n","docstr":" Given two integers left and right, return the count of numbers in the inclusive range [left, right] having a prime number of set bits in their binary representation.\n\n Recall that the number of set bits an integer has is the number of 1's present when written in binary.\n\n For example, 21 written in binary is 10101, which has 3 set bits.\n","code":"    count = 0\n    for i in range(left, right + 1):\n        print(i, \":\", bin(i))\n        c = 0\n        n = bin(i).count(\"1\")\n        for j in range(1, n + 1):\n            if n % j == 0:\n                c += 1\n        if c == 2:\n            count += 1\n    return count\n","test":"    def test_left_equal_to_right(self):\n        left = 10\n        right = 10\n        expected = 1\n        self.assertEqual(countPrimeSetBits(left, right), expected)\n\n    def test_no_prime_set_bits(self):\n        left = 1\n        right = 10\n        expected = 6\n        self.assertEqual(countPrimeSetBits(left, right), expected)\n\n    def test_all_prime_set_bits(self):\n        left = 10\n        right = 15\n        expected = 5\n        self.assertEqual(countPrimeSetBits(left, right), expected)\n\n    def test_mixed_prime_set_bits(self):\n        left = 3\n        right = 7\n        expected = 4\n        self.assertEqual(countPrimeSetBits(left, right), expected)\n\n    def test_large_range(self):\n        left = 1000\n        right = 1010\n        expected = 5\n        self.assertEqual(countPrimeSetBits(left, right), expected)\n\nclass TestCountPrimeSetBits(unittest.TestCase):\n    def test_left_equal_to_right(self):\n        left = 10\n        right = 10\n        expected = 0\n        self.assertEqual(countPrimeSetBits(left, right), expected)\n\n    def test_no_prime_set_bits(self):\n        left = 1\n        right = 10\n        expected = 4\n        self.assertEqual(countPrimeSetBits(left, right), expected)\n\n    def test_all_prime_set_bits(self):\n        left = 10\n        right = 15\n        expected = 4\n        self.assertEqual(countPrimeSetBits(left, right), expected)\n\n    def test_mixed_prime_set_bits(self):\n        left = 3\n        right = 7\n        expected = 3\n        self.assertEqual(countPrimeSetBits(left, right), expected)\n\n    def test_large_range(self):\n        left = 1000\n        right = 1010\n        expected = 5\n        self.assertEqual(countPrimeSetBits(left, right), expected)\n"},{"function_name":"isRectangleOverlap","header":"def isRectangleOverlap(rec1: List[int], rec2: List[int]) -> bool:\n","docstr":" An axis-aligned rectangle is represented as a list [x1, y1, x2, y2], where (x1, y1) is the coordinate of its bottom-left corner, and (x2, y2) is the coordinate of its top-right corner. Its top and bottom edges are parallel to the X-axis, and its left and right edges are parallel to the Y-axis.\n\n Two rectangles overlap if the area of their intersection is positive. To be clear, two rectangles that only touch at the corner or edges do not overlap.\n\n Given two axis-aligned rectangles rec1 and rec2, return true if they overlap, otherwise return false.\n\n rec1.length == 4\n rec2.length == 4\n -109 <= rec1[i], rec2[i] <= 109\n rec1 and rec2 represent a valid rectangle with a non-zero area.\n","code":"    def overlap(a1, a2, b1, b2):\n        if a1 > b1:\n            a1, a2, b1, b2 = b1, b2, a1, a2\n\n        if a2 <= b1:\n            return False\n        else:\n            return True\n\n    ax1, ay1, ax2, ay2 = rec1[0], rec1[1], rec1[2], rec1[3]\n    bx1, by1, bx2, by2 = rec2[0], rec2[1], rec2[2], rec2[3]\n    if not overlap(ax1, ax2, bx1, bx2) or not overlap(ay1, ay2, by1, by2):\n        return False\n    else:\n        return True\n","test":"    def test_overlap(self):\n        rec1 = [0, 0, 2, 2]\n        rec2 = [1, 1, 3, 3]\n        result = isRectangleOverlap(rec1, rec2)\n        self.assertTrue(result)\n\n    def test_no_overlap(self):\n        rec1 = [0, 0, 1, 1]\n        rec2 = [2, 2, 3, 3]\n        result = isRectangleOverlap(rec1, rec2)\n        self.assertFalse(result)\n\n    def test_partial_overlap(self):\n        rec1 = [0, 0, 2, 2]\n        rec2 = [1, 1, 2, 3]\n        result = isRectangleOverlap(rec1, rec2)\n        self.assertTrue(result)\n\n    def test_same_rectangle(self):\n        rec1 = [0, 0, 2, 2]\n        rec2 = [0, 0, 2, 2]\n        result = isRectangleOverlap(rec1, rec2)\n        self.assertTrue(result)\n\n    def test_single_point_overlap(self):\n        rec1 = [0, 0, 1, 1]\n        rec2 = [1, 1, 2, 2]\n        result = isRectangleOverlap(rec1, rec2)\n        self.assertFalse(result)\n\n    def test_minimum_area_rectangle(self):\n        rec1 = [0, 0, 0, 0]\n        rec2 = [0, 0, 0, 0]\n        result = isRectangleOverlap(rec1, rec2)\n        self.assertFalse(result)\n"},{"function_name":"removeDuplicates","header":"def removeDuplicates(s: str) -> str:\n","docstr":"","code":"    ans = []\n    for a in s:\n        if len(ans) > 0 and ans[-1] == a:\n            ans.pop()\n        else:\n            ans.append(a)\n    return \"\".join(ans)\n","test":"    def test_no_duplicates(self):\n        s = \"abcd\"\n        expected = \"abcd\"\n        self.assertEqual(removeDuplicates(s), expected)\n\n    def test_duplicates_at_beginning(self):\n        s = \"aabbcccddd\"\n        expected = \"cd\"\n        self.assertEqual(removeDuplicates(s), expected)\n\n    def test_duplicates_at_end(self):\n        s = \"abcdefghhh\"\n        expected = \"abcdefgh\"\n        self.assertEqual(removeDuplicates(s), expected)\n\n    def test_duplicates_in_middle(self):\n        s = \"kaabbccddeel\"\n        expected = \"kl\"\n        self.assertEqual(removeDuplicates(s), expected)\n\n    def test_empty_string(self):\n        s = \"\"\n        expected = \"\"\n        self.assertEqual(removeDuplicates(s), expected)\n"},{"function_name":"removeDuplicates","header":"def removeDuplicates(nums):\n","docstr":" Given an integer array nums sorted in non-decreasing order, remove the duplicates in-place such that each unique element appears only once. The relative order of the elements should be kept the same. Then return the number of unique elements in nums.\n\n Consider the number of unique elements of nums to be k, to get accepted, you need to do the following things:\n\n Change the array nums such that the first k elements of nums contain the unique elements in the order they were present in nums initially. The remaining elements of nums are not important as well as the size of nums.\n Return k.\n","code":"    j = 0\n    for i in range(1, len(nums)):\n        if nums[j] != nums[i]:\n            j += 1\n            nums[j] = nums[i]\n    return j + 1\n","test":"    def test_no_duplicates(self):\n        nums = [1, 2, 3, 4, 5]\n        expected_output = 5\n        self.assertEqual(removeDuplicates(nums), expected_output)\n        self.assertEqual(nums[:expected_output], [1, 2, 3, 4, 5])\n\n    def test_duplicates_present(self):\n        nums = [1, 1, 2, 2, 3]\n        expected_output = 3\n        self.assertEqual(removeDuplicates(nums), expected_output)\n        self.assertEqual(nums[:expected_output], [1, 2, 3])\n\n    def test_single_element_list(self):\n        nums = [5]\n        expected_output = 1\n        self.assertEqual(removeDuplicates(nums), expected_output)\n        self.assertEqual(nums[:expected_output], [5])\n\n    def test_all_duplicates(self):\n        nums = [2, 2, 2, 2, 2]\n        expected_output = 1\n        self.assertEqual(removeDuplicates(nums), expected_output)\n        self.assertEqual(nums[:expected_output], [2])\n"},{"function_name":"removeElement","header":"def removeElement(nums, val):\n","docstr":"","code":"    while val in nums:\n        nums.remove(val)\n    return len(nums)\n","test":"    def test_remove_element(self):\n        nums = [3, 2, 2, 3]\n        val = 3\n        expected_output = 2\n        self.assertEqual(removeElement(nums, val), expected_output)\n        self.assertEqual(nums, [2, 2])\n\n    def test_remove_all_elements(self):\n        nums = [1, 1, 1, 1]\n        val = 1\n        expected_output = 0\n        self.assertEqual(removeElement(nums, val), expected_output)\n        self.assertEqual(nums, [])\n\n    def test_remove_no_elements(self):\n        nums = [4, 5, 6]\n        val = 1\n        expected_output = 3\n        self.assertEqual(removeElement(nums, val), expected_output)\n        self.assertEqual(nums, [4, 5, 6])\n\n\n    def test_remove_duplicate_elements(self):\n        nums = [2, 2, 3, 3, 4]\n        val = 3\n        expected_output = 3\n        self.assertEqual(removeElement(nums, val), expected_output)\n        self.assertEqual(nums, [2, 2, 4])\n"},{"function_name":"removeOuterParentheses","header":"def removeOuterParentheses(s: str) -> str:\n","docstr":" A valid parentheses string is either empty \"\", \"(\" + A + \")\", or A + B, where A and B are valid parentheses strings, and + represents string concatenation.\n\n For example, \"\", \"()\", \"(())()\", and \"(()(()))\" are all valid parentheses strings.\n A valid parentheses string s is primitive if it is nonempty, and there does not exist a way to split it into s = A + B, with A and B nonempty valid parentheses strings.\n\n Given a valid parentheses string s, consider its primitive decomposition: s = P1 + P2 + ... + Pk, where Pi are primitive valid parentheses strings.\n\n Return s after removing the outermost parentheses of every primitive string in the primitive decomposition of s.\n\n Constraints:\n\n 1 <= s.length <= 105\n s[i] is either '(' or ')'.\n s is a valid parentheses string.\n","code":"    ans, cnt = [], 0\n    for ch in s:\n        if ch == '(' and cnt > 0:\n            ans.append(ch)\n        if ch == ')' and cnt > 1:\n            ans.append(ch)\n        cnt += 1 if ch == '(' else -1\n    return \"\".join(ans)\n","test":"    def test_single_parentheses(self):\n        s = \"()\"\n        expected = \"\"\n        self.assertEqual(removeOuterParentheses(s), expected)\n\n    def test_nested_parentheses(self):\n        s = \"(()())\"\n        expected = \"()()\"\n        self.assertEqual(removeOuterParentheses(s), expected)\n\n    def test_multiple_groups(self):\n        s = \"()()(()())\"\n        expected = \"()()\"\n        self.assertEqual(removeOuterParentheses(s), expected)\n\n    def test_no_outer_parentheses(self):\n        s = \"()()()\"\n        expected = \"\"\n        self.assertEqual(removeOuterParentheses(s), expected)\n\n    def test_empty_string(self):\n        s = \"\"\n        expected = \"\"\n        self.assertEqual(removeOuterParentheses(s), expected)\n"},{"function_name":"reverseVowels","header":"def reverseVowels(s: str) -> str:\n","docstr":"","code":"    q = []\n    vowels = ['a', 'i', 'e', 'o', 'u', 'A', 'E', 'I', 'O', 'U']\n    for char in s:\n        if char in vowels:\n            q.append(char)\n            s = s.replace(char, '*', 1)\n    q.reverse()\n    k = 0\n    for char in s:\n        if char == '*':\n            s = s.replace(\"*\", q[k], 1)\n            k += 1\n    return s\n","test":"    def test_no_vowels(self):\n        s = \"xyz\"\n        expected = \"xyz\"\n        self.assertEqual(reverseVowels(s), expected)\n\n    def test_single_vowel(self):\n        s = \"hello\"\n        expected = \"holle\"\n        self.assertEqual(reverseVowels(s), expected)\n\n    def test_multiple_vowels(self):\n        s = \"leetcode\"\n        expected = \"leotcede\"\n        self.assertEqual(reverseVowels(s), expected)\n\n    def test_same_vowel(self):\n        s = \"aaeeii\"\n        expected = \"iiEEaa\"\n        expected = \"iieeaa\"\n        self.assertEqual(reverseVowels(s), expected)\n"},{"function_name":"romanToInt","header":"def romanToInt(s):\n","docstr":"\n\n Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M.\n\n Symbol       Value\n I             1\n V             5\n X             10\n L             50\n C             100\n D             500\n M             1000\n For example, 2 is written as II in Roman numeral, just two ones added together. 12 is written as XII, which is simply X + II. The number 27 is written as XXVII, which is XX + V + II.\n\n Roman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used:\n\n I can be placed before V (5) and X (10) to make 4 and 9.\n X can be placed before L (50) and C (100) to make 40 and 90.\n C can be placed before D (500) and M (1000) to make 400 and 900.\n Given a roman numeral, convert it to an integer.\n","code":"    roman = {\"I\": 1, \"V\": 5, \"X\": 10, \"L\": 50, \"C\": 100, \"D\": 500, \"M\": 1000}\n    number = 0\n    for i in range(len(s) - 1):\n        if roman[s[i]] < roman[s[i + 1]]:\n            number -= roman[s[i]]\n        else:\n            number += roman[s[i]]\n    return number + roman[s[-1]]\n","test":"    def test_single_roman_symbol(self):\n        s = \"X\"\n        expected_output = 10\n        self.assertEqual(romanToInt(s), expected_output)\n\n    def test_roman_symbols_in_ascending_order(self):\n        s = \"VII\"\n        expected_output = 7\n        self.assertEqual(romanToInt(s), expected_output)\n\n    def test_roman_symbols_in_descending_order(self):\n        s = \"IX\"\n        expected_output = 9\n        self.assertEqual(romanToInt(s), expected_output)\n\n    def test_roman_symbols_mixed_order(self):\n        s = \"MCMXCIV\"\n        expected_output = 1994\n        self.assertEqual(romanToInt(s), expected_output)\n"},{"function_name":"selfDividingNumbers","header":"def selfDividingNumbers(left: int, right: int) -> List[int]:\n","docstr":" A self-dividing number is a number that is divisible by every digit it contains.\n\n For example, 128 is a self-dividing number because 128 % 1 == 0, 128 % 2 == 0, and 128 % 8 == 0.\n A self-dividing number is not allowed to contain the digit zero.\n\n Given two integers left and right, return a list of all the self-dividing numbers in the range [left, right].\n\n 1 <= left <= right <= 104\n","code":"    list1 = []\n\n    def selfdiv(num):\n        current = 0\n        x = num\n        while num > 0:\n            current = num % 10\n            if current == 0:\n                return False\n            if x % current != 0:\n                return False\n            num = num \/\/ 10\n        return True\n\n    for i in range(left, right + 1):\n        if selfdiv(i):\n            list1.append(i)\n    return list1\n","test":"    def test_valid_range(self):\n        result = selfDividingNumbers(1, 100)\n        self.assertListEqual(result,\n                             [1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 12, 15, 22, 24, 33, 36, 44, 48, 55, 66, 77, 88, 99])\n\n    def test_empty_range(self):\n        result = selfDividingNumbers(10, 9)\n        self.assertListEqual(result, [])\n\n    def test_single_number(self):\n        result = selfDividingNumbers(22, 22)\n        self.assertListEqual(result, [22])\n\n    def test_no_self_dividing_numbers(self):\n        result = selfDividingNumbers(30, 35)\n        self.assertListEqual(result, []) # comment this and uncomment the next line\n        # self.assertListEqual(result, [33])\n\n    def test_all_self_dividing_numbers(self):\n        result = selfDividingNumbers(1, 100)\n        self.assertListEqual(result,\n                             [1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 12, 15, 22, 24, 33, 36, 44, 48, 55, 66, 77, 88, 99])\n"},{"function_name":"areSentencesSimilar","header":"def areSentencesSimilar(sentence1, sentence2, similarPairs) :\n","docstr":" We can represent a sentence as an array of words, for example, the sentence \"I am happy with leetcode\" can be represented as arr = [\"I\",\"am\",happy\",\"with\",\"leetcode\"].\n","code":"    return len(sentence1) == len(sentence2) and all \\\n        (s1 == s2 or [s1, s2] in similarPairs or [s2, s1] in similarPairs for s1, s2 in zip(sentence1, sentence2))\n","test":"    def test_equal_sentences(self):\n        sentence1 = [\"Hello\", \"World\"]\n        sentence2 = [\"Hello\", \"World\"]\n        similarPairs = []\n        result = areSentencesSimilar(sentence1, sentence2, similarPairs)\n        self.assertTrue(result)\n\n    def test_similar_pairs(self):\n        sentence1 = [\"Hello\", \"World\"]\n        sentence2 = [\"Hola\", \"Mundo\"]\n        similarPairs = [[\"Hello\", \"Hola\"], [\"World\", \"Mundo\"]]\n        result = areSentencesSimilar(sentence1, sentence2, similarPairs)\n        self.assertTrue(result)\n\n    def test_no_similar_pairs(self):\n        sentence1 = [\"Hello\", \"World\"]\n        sentence2 = [\"Hola\", \"Mundo\"]\n        similarPairs = []\n        result = areSentencesSimilar(sentence1, sentence2, similarPairs)\n        self.assertFalse(result)\n\n    def test_mismatched_lengths(self):\n        sentence1 = [\"Hello\", \"World\"]\n        sentence2 = [\"Hello\"]\n        similarPairs = []\n        result = areSentencesSimilar(sentence1, sentence2, similarPairs)\n        self.assertFalse(result)\n\n    def test_empty_sentences(self):\n        sentence1 = []\n        sentence2 = []\n        similarPairs = []\n        result = areSentencesSimilar(sentence1, sentence2, similarPairs)\n        self.assertTrue(result)\n"},{"function_name":"sortedSquares","header":"def sortedSquares(nums: List[int]) -> List[int]:\n","docstr":" Given an integer array nums sorted in non-decreasing order, return an array of the squares of each number sorted in non-decreasing order.\n","code":"    a = [i * i for i in nums]\n    return sorted(a)\n","test":"    def test_sorted_squares(self):\n        nums = [-4, -1, 0, 3, 10]\n        result = sortedSquares(nums)\n        self.assertEqual(result, [0, 1, 9, 16, 100])\n\n    def test_sorted_squares_negative_numbers(self):\n        nums = [-7, -3, -2, 0, 5]\n        result = sortedSquares(nums)\n        self.assertEqual(result, [0, 4, 9, 25, 49])\n\n    def test_sorted_squares_positive_numbers(self):\n        nums = [1, 2, 3, 4, 5]\n        result = sortedSquares(nums)\n        self.assertEqual(result, [1, 4, 9, 16, 25])\n\n    def test_sorted_squares_zero(self):\n        nums = [0]\n        result = sortedSquares(nums)\n        self.assertEqual(result, [0])\n\n    def test_sorted_squares_empty_list(self):\n        nums = []\n        result = sortedSquares(nums)\n        self.assertEqual(result, [])\n"},{"function_name":"sumOfMultiples","header":"def sumOfMultiples( n: int) -> int:\n","docstr":"","code":"    ans = 0\n    for x in range(1, n + 1):\n        if x % 3 == 0 or x % 5 == 0 or x % 7 == 0:\n            ans += x\n\n    return ans\n","test":"    def test_sum_of_multiples(self):\n        # Replace YourClass with the actual class name\n\n        # Test Case 1\n        self.assertEqual(sumOfMultiples(10), 40)\n\n        # Test Case 2\n        self.assertEqual(sumOfMultiples(20), 119)\n\n        # Test Case 3\n        self.assertEqual(sumOfMultiples(5), 8)\n\n        # Test Case 4\n        self.assertEqual(sumOfMultiples(15), 81)\n\n        # Test Case 5\n        self.assertEqual(sumOfMultiples(1), 0)\n"},{"function_name":"surfaceArea","header":"def surfaceArea(grid: List[List[int]]) -> int:\n","docstr":" You are given an n x n grid where you have placed some 1 x 1 x 1 cubes. Each value v = grid[i][j] represents a tower of v cubes placed on top of cell (i, j).\n\n After placing these cubes, you have decided to glue any directly adjacent cubes to each other, forming several irregular 3D shapes.\n\n Return the total surface area of the resulting shapes.\n\n Note: The bottom face of each shape counts toward its surface area.\n","code":"    l = len(grid)\n    area = 0\n    for row in range(l):\n        for col in range(l):\n            if grid[row][col]:\n                area += (grid[row][col] * 4) + 2  # surface area of each block if blocks weren't connected\n            if row:  # row > 0\n                area -= min(grid[row][col], grid[row - 1][col]) * 2  # subtracting as area is common among two blocks\n            if col:  # col > 0\n                area -= min(grid[row][col], grid[row][col - 1]) * 2  # subtracting as area is common among two blocks\n    return area\n","test":"    def test_empty_grid(self):\n        grid = []\n        expected = 0\n        self.assertEqual(surfaceArea(grid), expected)\n\n    def test_single_block(self):\n        grid = [[1]]\n        expected = 6\n        self.assertEqual(surfaceArea(grid), expected)\n\n    def test_multiple_blocks(self):\n        grid = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]\n        expected = 102\n        self.assertEqual(surfaceArea(grid), expected)\n\n    def test_zero_blocks(self):\n        grid = [[0, 0], [0, 0]]\n        expected = 0\n        self.assertEqual(surfaceArea(grid), expected)\n\n    def test_large_grid(self):\n        grid = [[3, 2, 1, 0, 4], [2, 5, 6, 7, 3], [1, 0, 3, 4, 2], [2, 1, 0, 3, 2], [4, 3, 2, 1, 0]]\n        expected = 164\n        self.assertEqual(surfaceArea(grid), expected)\n"},{"function_name":"twoSum","header":"def twoSum(nums, target):\n","docstr":" Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.\n\n You may assume that each input would have exactly one solution, and you may not use the same element twice.\n\n You can return the answer in any order.\n","code":"    d = {}\n    for i, j in enumerate(nums):\n        r = target - j\n        if r in d:\n            return [d[r], i]\n        d[j] = i\n","test":"    def test_target_present(self):\n        nums = [2, 7, 11, 15]\n        target = 9\n        expected_output = [0, 1]\n        self.assertEqual(twoSum(nums, target), expected_output)\n\n    def test_target_not_present(self):\n        nums = [3, 6, 8, 12]\n        target = 5\n        expected_output = None\n        self.assertEqual(twoSum(nums, target), expected_output)\n\n    def test_duplicate_values(self):\n        nums = [2, 7, 11, 15, 7]\n        target = 14\n        expected_output = [1, 4]\n        self.assertEqual(twoSum(nums, target), expected_output)\n\n    def test_negative_numbers(self):\n        nums = [-2, -7, 11, 15]\n        target = 9\n        expected_output = [0, 2]\n        self.assertEqual(twoSum(nums, target), expected_output)\n\n    def test_empty_array(self):\n        nums = []\n        target = 9\n        expected_output = None\n        self.assertEqual(twoSum(nums, target), expected_output)\n\n    def test_single_element_array(self):\n        nums = [5]\n        target = 5\n        expected_output = None\n        self.assertEqual(twoSum(nums, target), expected_output)\n"},{"function_name":"isValid","header":"def isValid( s: str) -> bool:\n","docstr":" Given a string s containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid.\n\n An input string is valid if:\n\n Open brackets must be closed by the same type of brackets.\n Open brackets must be closed in the correct order.\n Every close bracket has a corresponding open bracket of the same type.\n","code":"    stack = []\n    for char in s:\n        if char == '(' or char == '{' or char == '[':\n            stack.append(char)\n        else:\n            if not stack:\n                return False\n            if char == ')' and stack[-1] == '(':\n                stack.pop()\n            elif char == '}' and stack[-1] == '{':\n                stack.pop()\n            elif char == ']' and stack[-1] == '[':\n                stack.pop()\n            else:\n                return False\n    return not stack\n","test":"    def test_is_valid(self):\n        # Replace YourClass with the actual class name\n\n        # Test Case 1\n        s = \"()\"\n        self.assertTrue(isValid(s))\n\n        # Test Case 2\n        s = \"()[]{}\"\n        self.assertTrue(isValid(s))\n\n        # Test Case 3\n        s = \"(]\"\n        self.assertFalse(isValid(s))\n\n        # Test Case 4\n        s = \"([)]\"\n        self.assertFalse(isValid(s))\n\n        # Test Case 5\n        s = \"{[]}\"\n        self.assertTrue(isValid(s))\n\n        # Additional Test Case 6\n        s = \"({[()]})\"\n        self.assertTrue(isValid(s))\n\n        # Additional Test Case 7\n        s = \"\"\n        self.assertTrue(isValid(s))\n\n        # Additional Test Case 8\n        s = \"[[[]]]\"\n        self.assertTrue(isValid(s))\n\n        # Additional Test Case 9\n        s = \"[[[[]]\"\n        self.assertFalse(isValid(s))\n"},{"function_name":"isBoomerang","header":"def isBoomerang(points: List[List[int]]) -> bool:\n","docstr":" Given an array points where points[i] = [xi, yi] represents a point on the X-Y plane, return true if these points are a boomerang.\n\n A boomerang is a set of three points that are all distinct and not in a straight line.\n\n Constraints:\n\n points.length == 3\n points[i].length == 2\n 0 <= xi, yi <= 100\n","code":"    a, b, c = points\n    return (b[1] - a[1]) * (c[0] - b[0]) != (c[1] - b[1]) * (b[0] - a[0])\n","test":"    def test_valid_boomerang(self):\n        points = [[1, 1], [2, 3], [3, 2]]\n        expected = True\n        self.assertEqual(isBoomerang(points), expected)\n\n    def test_invalid_boomerang(self):\n        points = [[1, 1], [2, 2], [3, 3]]\n        expected = False\n        self.assertEqual(isBoomerang(points), expected)\n\n    def test_horizontal_line(self):\n        points = [[1, 1], [2, 1], [3, 1]]\n        expected = False\n        self.assertEqual(isBoomerang(points), expected)\n\n    def test_vertical_line(self):\n        points = [[1, 1], [1, 2], [1, 3]]\n        expected = False\n        self.assertEqual(isBoomerang(points), expected)\n\n    def test_same_points(self):\n        points = [[1, 1], [1, 1], [1, 1]]\n        expected = False\n        self.assertEqual(isBoomerang(points), expected)\n"},{"function_name":"validWordAbbreviation","header":"def validWordAbbreviation(word: str, abbr: str) -> bool:\n","docstr":"","code":"    p1 = p2 = 0\n    while p1 < len(word) and p2 < len(abbr):\n        if abbr[p2].isdigit():\n            if abbr[p2] == '0':  # leading zeros are invalid\n                return False\n            shift = 0\n            while p2 < len(abbr) and abbr[p2].isdigit():\n                shift = (shift * 10) + int(abbr[p2])\n                p2 += 1\n            p1 += shift\n        else:\n            if word[p1] != abbr[p2]:\n                return False\n            p1 += 1\n            p2 += 1\n    return p1 == len(word) and p2 == len(abbr)\n","test":"    def test_valid_abbreviation(self):\n        word = \"international\"\n        abbr = \"i12al\"\n        # abbr = \"i10al\"\n        expected = True\n        self.assertEqual(validWordAbbreviation(word, abbr), expected)\n\n    def test_invalid_abbreviation(self):\n        word = \"apple\"\n        abbr = \"a4e\"\n        expected = False\n        self.assertEqual(validWordAbbreviation(word, abbr), expected)\n\n    def test_leading_zeros(self):\n        word = \"algorithm\"\n        abbr = \"0l9m\"\n        expected = False\n        self.assertEqual(validWordAbbreviation(word, abbr), expected)\n\n    def test_same_length_word_and_abbr(self):\n        word = \"python\"\n        abbr = \"p6n\"\n        expected = False\n        self.assertEqual(validWordAbbreviation(word, abbr), expected)\n"},{"function_name":"isAlienSorted","header":"def isAlienSorted(words: List[str], order: str) -> bool:\n","docstr":" Input: words = [\"apple\",\"app\"], order = \"abcdefghijklmnopqrstuvwxyz\"\n Output: false\n Explanation: The first three characters \"app\" match, and the second string is shorter (in size.) According to lexicographical rules \"apple\" > \"app\",\n because 'l' > '\u2205', where '\u2205' is defined as the blank character which is less than any other character (More info).\n\n Constraints:\n\n 1 <= words.length <= 100\n 1 <= words[i].length <= 20\n order.length == 26\n All characters in words[i] and order are English lowercase letters.\n","code":"    order_counter = {value: index for index, value in enumerate(order)}\n\n    for i in range(len(words)-1):\n        word1, word2 = words[i], words[i+1]\n\n        for j in range(len(word1)):\n            if j == len(word2):\n                return False\n\n            if word1[j] != word2[j]:\n                if order_counter[word2[j]] < order_counter[word1[j]]:\n                    return False\n\n                break\n\n    return True\n","test":"    def test_empty_words(self):\n        words = []\n        order = \"abcdefghijklmnopqrstuvwxyz\"\n        expected = True\n        self.assertEqual(isAlienSorted(words, order), expected)\n\n    def test_single_word(self):\n        words = [\"apple\"]\n        order = \"abcdefghijklmnopqrstuvwxyz\"\n        expected = True\n        self.assertEqual(isAlienSorted(words, order), expected)\n\n    def test_sorted_words(self):\n        words = [\"hello\", \"leetcode\", \"world\"]\n        order = \"hlabcdefgijkmnopqrstuvwxyz\"\n        expected = True\n        self.assertEqual(isAlienSorted(words, order), expected)\n\n    def test_unsorted_words(self):\n        words = [\"word\", \"world\", \"hello\"]\n        order = \"hlabcdefgijkmnopqrstuvwxyz\"\n        expected = False\n        self.assertEqual(isAlienSorted(words, order), expected)\n\n    def test_same_starting_letters(self):\n        words = [\"apple\", \"ape\", \"application\"]\n        order = \"abcdefghijklmnopqrstuvwxyz\"\n        expected = False\n        self.assertEqual(isAlienSorted(words, order), expected)\n\n    def test_same_words(self):\n        words = [\"same\", \"same\", \"same\"]\n        order = \"abcdefghijklmnopqrstuvwxyz\"\n        expected = True\n        self.assertEqual(isAlienSorted(words, order), expected)\n\n    def test_custom_order(self):\n        words = [\"word\", \"leetcode\", \"hello\"]\n        order = \"olhecdtbwjsykarxvznipgufmq\"\n        expected = False\n        self.assertEqual(isAlienSorted(words, order), expected)\n"},{"function_name":"increasing_triplet","header":"def increasing_triplet(nums):","docstr":"","code":"    min_value = float('inf')\n    second_min_value = float('inf')\n    \n    for num in nums:\n        if num <= min_value:\n            min_value = num\n        elif num <= second_min_value:\n            second_min_value = num\n        else:\n            return True\n\n    return False\n","test":"    def test_empty_array(self):\n        self.assertFalse(increasing_triplet([]))\n    \n    def test_single_element_array(self):\n        self.assertFalse(increasing_triplet([5]))\n        self.assertFalse(increasing_triplet([0]))\n    \n    def test_all_equal_elements(self):\n        self.assertFalse(increasing_triplet([3, 3, 3, 3, 3]))\n        self.assertFalse(increasing_triplet([0, 0, 0, 0, 0]))\n    \n    def test_all_increasing_elements(self):\n        self.assertTrue(increasing_triplet([1, 2, 3, 4, 5]))\n    \n    def test_no_triplet_exists(self):\n        self.assertFalse(increasing_triplet([5, 4, 3, 2, 1]))\n    \n    def test_triplet_exists(self):\n        self.assertTrue(increasing_triplet([1, 3, 2, 4, 5]))\n        self.assertTrue(increasing_triplet([5, 2, 4, 1, 3, 7]))\n\n"},{"function_name":"intersection","header":"def intersection(nums1, nums2):","docstr":"","code":"    # Count the occurrences of each element in both arrays\n    count1 = Counter(nums1)\n    count2 = Counter(nums2)\n\n    # Find the common elements\n    common_elements = count1.keys() & count2.keys()\n\n    # Create a list containing the common elements repeated the minimum number of times\n    result = []\n    for num in common_elements:\n        count = min(count1[num], count2[num])\n        result.extend([num] * count)\n\n    return sorted(result)\n","test":"    def test_empty_arrays(self):\n        self.assertEqual(intersection([], []), [])\n\n    def test_no_common_elements(self):\n        self.assertEqual(intersection([1, 2, 3], [4, 5, 6]), [])\n        self.assertEqual(intersection([1, 2, 3], [4, 5, 6, 7]), [])\n\n    def test_common_elements(self):\n        self.assertEqual(intersection([1, 2, 2, 1], [2, 2]), [2, 2])\n        self.assertEqual(intersection([4, 9, 5], [9, 4, 9, 8, 4]), [4, 9])\n        self.assertEqual(intersection([1, 2, 2, 1, 1, 3], [2, 1, 1, 4]), [1, 1, 2])\n\n    def test_duplicate_elements(self):\n        self.assertEqual(intersection([1, 2, 2, 1], [2, 2, 2]), [2, 2])\n        self.assertEqual(intersection([1, 2, 2, 1], [2, 2, 1, 1, 1]), [1, 1, 2, 2])\n        self.assertEqual(intersection([1, 2, 2, 1], [1, 1]), [1, 1])\n\n    def test_result_order(self):\n        self.assertEqual(intersection([4, 2, 9, 1, 5], [9, 4, 1, 2, 8, 4]), [1, 2, 4, 9])\n\n"},{"function_name":"k_smallest_pairs","header":"def k_smallest_pairs(nums1, nums2, k):","docstr":"","code":"    pairs = []\n    \n    # Generate all possible pairs (u, v) and their sums\n    for u in nums1:\n        for v in nums2:\n            pairs.append((u + v, u, v))\n    \n    # Sort the pairs based on their sums\n    pairs.sort(key=lambda x: x[0])\n    \n    # Extract the k smallest pairs\n    result = [[u, v] for _, u, v in pairs[:k]]\n    \n    return result\n","test":"    def test_empty_lists(self):\n        nums1 = []\n        nums2 = []\n        k = 3\n        expected_output = []\n        self.assertEqual(k_smallest_pairs(nums1, nums2, k), expected_output)\n\n    def test_single_element_lists(self):\n        nums1 = [1]\n        nums2 = [2]\n        k = 1\n        expected_output = [[1, 2]]\n        self.assertEqual(k_smallest_pairs(nums1, nums2, k), expected_output)\n\n    def test_duplicate_elements(self):\n        nums1 = [1, 1, 2]\n        nums2 = [1, 2, 3]\n        k = 4\n        expected_output = [[1, 1], [1, 1], [1, 2], [1, 2]]\n        self.assertEqual(k_smallest_pairs(nums1, nums2, k), expected_output)\n\n    def test_larger_lists(self):\n        nums1 = [1, 4, 6]\n        nums2 = [2, 3, 5]\n        k = 5\n        expected_output = [[1, 2], [1, 3], [1, 5], [4, 2], [4, 3]]\n        self.assertEqual(k_smallest_pairs(nums1, nums2, k), expected_output)\n\n    def test_k_greater_than_pairs_count(self):\n        nums1 = [1, 2, 3]\n        nums2 = [4, 5, 6]\n        k = 9\n        expected_output = [[1, 4], [1, 5], [2, 4], [1,6], [2,5], [3, 4], [2, 6], [3, 5], [3, 6]]\n        self.assertEqual(k_smallest_pairs(nums1, nums2, k), expected_output)\n\n    def test_empty_result(self):\n        nums1 = [5, 6, 7]\n        nums2 = [1, 2, 3]\n        k = 0\n        expected_output = []\n        self.assertEqual(k_smallest_pairs(nums1, nums2, k), expected_output)\n\n"},{"function_name":"kth_smallest_in_matrix","header":"def kth_smallest_in_matrix(matrix, k):","docstr":"","code":"    m = len(matrix)\n    if m > 0:\n        n = len(matrix[0])\n    else:\n        return None\n\n    if m * n < k:\n        return None\n    \n    # Flatten the matrix into a 1D array\n    flattened = [element for row in matrix for element in row]\n\n    # Sort the flattened array in ascending order\n    flattened.sort()\n\n    # Return the kth smallest element\n    return flattened[k - 1]\n","test":"    def test_kth_smallest_square_matrix(self):\n        matrix = [\n            [1, 3, 5],\n            [2, 4, 6],\n            [7, 8, 9]\n        ]\n        k = 5\n        self.assertEqual(kth_smallest_in_matrix(matrix, k), 5)\n\n    def test_k_bigger_than_matrix_size(self):\n        matrix = [\n            [1, 3, 5],\n            [2, 4, 6],\n            [7, 8, 9]\n        ]\n        k = 10\n        self.assertIsNone(kth_smallest_in_matrix(matrix, k))\n\n    def test_kth_smallest_rectangular_matrix(self):\n        matrix = [\n            [8, 8, 2],\n            [3, 2, 9],\n            [88, 12, 3],\n            [15, 2, 5]\n        ]\n        k = 9\n        self.assertEqual(kth_smallest_in_matrix(matrix, k), 9)\n\n    def test_kth_smallest_single_row_matrix(self):\n        matrix = [[1, 2, 3]]\n        k = 2\n        self.assertEqual(kth_smallest_in_matrix(matrix, k), 2)\n\n    def test_kth_smallest_single_column_matrix(self):\n        matrix = [\n            [1],\n            [2],\n            [3]\n        ]\n        k = 3\n        self.assertEqual(kth_smallest_in_matrix(matrix, k), 3)\n\n    def test_kth_smallest_empty_matrix(self):\n        matrix = []\n        k = 1\n        self.assertIsNone(kth_smallest_in_matrix(matrix, k))\n\n    def test_kth_smallest_single_element_matrix(self):\n        matrix = [[5]]\n        k = 1\n        self.assertEqual(kth_smallest_in_matrix(matrix, k), 5)\n\n"},{"function_name":"first_duplicate_in_list","header":"def first_duplicate_in_list(lst):","docstr":"","code":"    seen = set()\n    for item in lst:\n        if item in seen:\n            return item\n        seen.add(item)\n    return None\n","test":"    def test_duplicate_found(self):\n        lst = [1, 2, 3, 4, 3, 5]\n        self.assertEqual(first_duplicate_in_list(lst), 3)\n\n        lst = ['a', 'b', 'c', 'd', 'c', 'e']\n        self.assertEqual(first_duplicate_in_list(lst), 'c')\n\n        lst = [2.71, 3.14, 1.41, 2.71, 3.14]\n        self.assertEqual(first_duplicate_in_list(lst), 2.71)\n\n    def test_no_duplicate_found(self):\n        lst = [1, 2, 3, 4, 5]\n        self.assertIsNone(first_duplicate_in_list(lst))\n\n        lst = ['a', 'b', 'c', 'd', 'e']\n        self.assertIsNone(first_duplicate_in_list(lst))\n\n        lst = [2.71, 3.14, 1.41]\n        self.assertIsNone(first_duplicate_in_list(lst))\n\n"},{"function_name":"nth_digit_in_sequence","header":"def nth_digit_in_sequence(n):","docstr":"","code":"    if n == 0:\n        return None\n\n    digit_count = 1\n    start_num = 1\n    end_num = 9\n\n    while n > digit_count * (end_num - start_num + 1):\n        n -= digit_count * (end_num - start_num + 1)\n        digit_count += 1\n        start_num *= 10\n        end_num = end_num * 10 + 9\n\n    num = start_num + (n - 1) \/\/ digit_count\n    digit_position = (n - 1) % digit_count\n\n    return int(str(num)[digit_position])\n","test":"    def test_with_n_equal_zero(self):\n        self.assertEqual(nth_digit_in_sequence(0), None)\n        \n    def test_nth_digit_in_sequence(self):\n        self.assertEqual(nth_digit_in_sequence(1), 1)\n        self.assertEqual(nth_digit_in_sequence(2), 2)\n        self.assertEqual(nth_digit_in_sequence(10), 1)\n        self.assertEqual(nth_digit_in_sequence(11), 0)\n        self.assertEqual(nth_digit_in_sequence(12), 1)\n        self.assertEqual(nth_digit_in_sequence(15), 2)\n        self.assertEqual(nth_digit_in_sequence(20), 1)\n        self.assertEqual(nth_digit_in_sequence(21), 5)\n        self.assertEqual(nth_digit_in_sequence(30), 2)\n        self.assertEqual(nth_digit_in_sequence(100), 5)\n        self.assertEqual(nth_digit_in_sequence(500), 0)\n        self.assertEqual(nth_digit_in_sequence(1000), 3)\n\n"},{"function_name":"cross_product","header":"def cross_product(vector1, vector2):","docstr":"","code":"    if len(vector1) != 3 or len(vector2) != 3:\n        raise ValueError(\"Vectors must be of length 3.\")\n\n    result = [\n        vector1[1] * vector2[2] - vector1[2] * vector2[1],\n        vector1[2] * vector2[0] - vector1[0] * vector2[2],\n        vector1[0] * vector2[1] - vector1[1] * vector2[0]\n    ]\n    \n    return result\n","test":"    def test_cross_product_calculation(self):\n        vector1 = [1, 2, 3]\n        vector2 = [4, 5, 6]\n        expected_result = [-3, 6, -3]\n        self.assertEqual(cross_product(vector1, vector2), expected_result)\n\n    def test_invalid_vector_length(self):\n        vector1 = [1, 2, 3, 4]\n        vector2 = [4, 5, 6]\n        self.assertRaises(ValueError, cross_product, vector1, vector2)\n\n        vector1 = [1, 2]\n        vector2 = [4, 5, 6]\n        self.assertRaises(ValueError, cross_product, vector1, vector2)\n\n"},{"function_name":"fib","header":"def fib(n):  # return Fibonacci series up to n","docstr":"","code":"    result = []\n    a, b = 0, 1\n    while b < n:\n        result.append(b)\n        a, b = b, a + b\n    return result\n","test":"\n    def test_fibonacci_sequence(self):\n        n = 10\n        expected_result = [1, 1, 2, 3, 5, 8]\n        self.assertEqual(fib(n), expected_result)\n\n    def test_empty_sequence(self):\n        n = 1\n        expected_result = []\n        self.assertEqual(fib(n), expected_result)\n\n    def test_single_value_sequence(self):\n        n = 2\n        expected_result = [1, 1]\n        self.assertEqual(fib(n), expected_result)\n\n"},{"function_name":"reverse_string_recursive","header":"def reverse_string_recursive(string):","docstr":"","code":"    if len(string) <= 1:\n        return string\n    return reverse_string_recursive(string[1:]) + string[0]\n","test":"\n    def test_reverse_string(self):\n        string = \"Hello, World!\"\n        expected_result = \"!dlroW ,olleH\"\n        self.assertEqual(reverse_string_recursive(string), expected_result)\n\n    def test_empty_string(self):\n        string = \"\"\n        expected_result = \"\"\n        self.assertEqual(reverse_string_recursive(string), expected_result)\n\n    def test_single_character_string(self):\n        string = \"A\"\n        expected_result = \"A\"\n        self.assertEqual(reverse_string_recursive(string), expected_result)\n\n\n"},{"function_name":"caesar_cipher","header":"def caesar_cipher(string, key):","docstr":"","code":"    result = \"\"\n    for char in string:\n        if char.isalpha():\n            ascii_offset = ord('A') if char.isupper() else ord('a')\n            shifted_char = chr((ord(char) - ascii_offset + key) % 26 + ascii_offset)\n            result += shifted_char\n        else:\n            result += char\n    return result\n","test":"\n    def test_caesar_cipher(self):\n        string = \"Hello, World!\"\n        key = 3\n        expected_result = \"Khoor, Zruog!\"\n        self.assertEqual(caesar_cipher(string, key), expected_result)\n\n    def test_empty_string(self):\n        string = \"\"\n        key = 5\n        expected_result = \"\"\n        self.assertEqual(caesar_cipher(string, key), expected_result)\n\n    def test_special_characters(self):\n        string = \"Hello, #123!\"\n        key = 1\n        expected_result = \"Ifmmp, #123!\"\n        self.assertEqual(caesar_cipher(string, key), expected_result)\n\n"},{"function_name":"indices_of_occurrences","header":"def indices_of_occurrences(string, char):","docstr":"","code":"    indices = []\n    for i in range(len(string)):\n        if string[i] == char:\n            indices.append(i)\n    return indices\n","test":"\n    def test_indices_exist(self):\n        string = \"Hello, World!\"\n        char = \"o\"\n        expected_result = [4, 8]\n        self.assertEqual(indices_of_occurrences(string, char), expected_result)\n\n    def test_no_indices_exist(self):\n        string = \"Hello, World!\"\n        char = \"x\"\n        expected_result = []\n        self.assertEqual(indices_of_occurrences(string, char), expected_result)\n\n    def test_empty_string(self):\n        string = \"\"\n        char = \"a\"\n        expected_result = []\n        self.assertEqual(indices_of_occurrences(string, char), expected_result)\n\n    def test_case_sensitive(self):\n        string = \"HelLo, WorLd!\"\n        char = \"L\"\n        expected_result = [3, 10]\n        self.assertEqual(indices_of_occurrences(string, char), expected_result)\n\n"},{"function_name":"is_arithmetic_sequence","header":"def is_arithmetic_sequence(arr):","docstr":"","code":"    if len(arr) <= 2:\n        return True\n\n    diff = arr[1] - arr[0]\n    for i in range(2, len(arr)):\n        if arr[i] - arr[i-1] != diff:\n            return False\n\n    return True\n","test":"    def test_arithmetic_sequence(self):\n        # Test cases with arithmetic sequences\n        self.assertTrue(is_arithmetic_sequence([1, 3, 5, 7, 9]))\n        self.assertTrue(is_arithmetic_sequence([0, 2, 4, 6, 8]))\n        self.assertTrue(is_arithmetic_sequence([-1, -3, -5, -7, -9]))\n        self.assertTrue(is_arithmetic_sequence([5, 5, 5, 5, 5, 5]))\n    \n    def test_arithmetic_by_length(self):\n        self.assertTrue(is_arithmetic_sequence([10]))\n        self.assertTrue(is_arithmetic_sequence([1, 5]))\n        self.assertTrue(is_arithmetic_sequence([]))\n\n    def test_non_arithmetic_sequence(self):\n        # Test cases with non-arithmetic sequences\n        self.assertFalse(is_arithmetic_sequence([1, 3, 6, 10, 15]))\n        self.assertFalse(is_arithmetic_sequence([2, 4, 6, 9, 11]))\n        self.assertFalse(is_arithmetic_sequence([1, 2, 3, 5, 8]))\n\n"},{"function_name":"reverse_quick_sort","header":"def reverse_quick_sort(arr):","docstr":"","code":"    if len(arr) <= 1:\n        return arr\n\n    pivot = arr[len(arr) \/\/ 2]\n    left = [x for x in arr if x > pivot]\n    middle = [x for x in arr if x == pivot]\n    right = [x for x in arr if x < pivot]\n\n    return reverse_quick_sort(left) + middle + reverse_quick_sort(right)\n","test":"\n    def test_reverse_quick_sort(self):\n        arr = [9, 3, 2, 7, 6, 8, 1, 5, 4]\n        expected = [9, 8, 7, 6, 5, 4, 3, 2, 1]\n        self.assertEqual(reverse_quick_sort(arr), expected)\n\n    def test_reverse_quick_sort_empty(self):\n        arr = []\n        expected = []\n        self.assertEqual(reverse_quick_sort(arr), expected)\n\n    def test_reverse_quick_sort_single_element(self):\n        arr = [5]\n        expected = [5]\n        self.assertEqual(reverse_quick_sort(arr), expected)\n\n    def test_reverse_quick_sort_already_sorted(self):\n        arr = [10, 8, 6, 4, 2]\n        expected = [10, 8, 6, 4, 2]\n        self.assertEqual(reverse_quick_sort(arr), expected)\n\n    def test_reverse_quick_sort_duplicate_elements(self):\n        arr = [5, 2, 7, 2, 1, 5]\n        expected = [7, 5, 5, 2, 2, 1]\n        self.assertEqual(reverse_quick_sort(arr), expected)\n\n"},{"function_name":"find_div_by_a_or_b","header":"def find_div_by_a_or_b(numbers, a, b):","docstr":"","code":"    result = []\n    for num in numbers:\n        if (num % a == 0) != (num % b == 0):\n            result.append(num)\n    return result\n","test":"\n    def test_divisible_by_a_or_b(self):\n        numbers = [15, 24, 25, 30, 35, 40, 45, 50]\n        a = 4\n        b = 10\n        expected = [24, 30, 50]\n        self.assertEqual(find_div_by_a_or_b(numbers, a, b), expected)\n\n    def test_no_numbers_divisible(self):\n        numbers = [11, 17, 23, 29, 31, 37]\n        a = 3\n        b = 5\n        expected = []\n        self.assertEqual(find_div_by_a_or_b(numbers, a, b), expected)\n\n    def test_all_numbers_divisible(self):\n        numbers = [10, 20, 30, 40, 50]\n        a = 10\n        b = 5\n        expected = []\n        self.assertEqual(find_div_by_a_or_b(numbers, a, b), expected)\n\n    def test_empty_list(self):\n        numbers = []\n        a = 5\n        b = 10\n        expected = []\n        self.assertEqual(find_div_by_a_or_b(numbers, a, b), expected)\n\n"},{"function_name":"transpose_matrix","header":"def transpose_matrix(matrix):","docstr":"","code":"    rows = len(matrix)\n    if rows == 0:\n        cols = 0\n    else:\n        cols = len(matrix[0])\n\n    transposed = [[0 for _ in range(rows)] for _ in range(cols)]\n\n    for i in range(rows):\n        for j in range(cols):\n            transposed[j][i] = matrix[i][j]\n\n    return transposed\n","test":"\n    def test_transpose_matrix(self):\n        matrix = [[1, 2, 3],\n                  [4, 5, 6],\n                  [7, 8, 9]]\n        expected = [[1, 4, 7],\n                    [2, 5, 8],\n                    [3, 6, 9]]\n        self.assertEqual(transpose_matrix(matrix), expected)\n\n    def test_transpose_empty_matrix(self):\n        matrix = []\n        expected = []\n        self.assertEqual(transpose_matrix(matrix), expected)\n\n    def test_transpose_single_row_matrix(self):\n        matrix = [[1, 2, 3]]\n        expected = [[1], [2], [3]]\n        self.assertEqual(transpose_matrix(matrix), expected)\n\n    def test_transpose_single_column_matrix(self):\n        matrix = [[1], [2], [3]]\n        expected = [[1, 2, 3]]\n        self.assertEqual(transpose_matrix(matrix), expected)\n\n    def test_transpose_rectangular_matrix(self):\n        matrix = [[1, 2, 3],\n                  [4, 5, 6]]\n        expected = [[1, 4],\n                    [2, 5],\n                    [3, 6]]\n        self.assertEqual(transpose_matrix(matrix), expected)\n\n"},{"function_name":"count_character_occurrences","header":"def count_character_occurrences(string):","docstr":"","code":"    counts = {}\n    for char in string:\n        if char in counts:\n            counts[char] += 1\n        else:\n            counts[char] = 1\n    return counts\n","test":"\n    def test_count_character_occurrences(self):\n        string = \"hello\"\n        expected = {'h': 1, 'e': 1, 'l': 2, 'o': 1}\n        self.assertEqual(count_character_occurrences(string), expected)\n\n    def test_count_character_occurrences_empty_string(self):\n        string = \"\"\n        expected = {}\n        self.assertEqual(count_character_occurrences(string), expected)\n\n    def test_count_character_occurrences_repeated_characters(self):\n        string = \"banana\"\n        expected = {'b': 1, 'a': 3, 'n': 2}\n        self.assertEqual(count_character_occurrences(string), expected)\n\n    def test_count_character_occurrences_case_sensitive(self):\n        string = \"Hello\"\n        expected = {'H': 1, 'e': 1, 'l': 2, 'o': 1}\n        self.assertEqual(count_character_occurrences(string), expected)\n\n"},{"function_name":"generate_string","header":"def generate_string(n, k):","docstr":"","code":"    result = \"\"\n    for i in range(n):\n        result += chr(k + i)\n    return result\n","test":"\n    def test_generate_string(self):\n        n = 5\n        k = 65\n        expected = \"ABCDE\"\n        self.assertEqual(generate_string(n, k), expected)\n\n    def test_generate_string_with_empty_input(self):\n        n = 0\n        k = 65\n        expected = \"\"\n        self.assertEqual(generate_string(n, k), expected)\n\n    def test_generate_string_with_negative_n(self):\n        n = -3\n        k = 65\n        expected = \"\"\n        self.assertEqual(generate_string(n, k), expected)\n\n    def test_generate_string_with_zero_k(self):\n        n = 5\n        k = 0\n        expected = \"\\x00\\x01\\x02\\x03\\x04\"\n        self.assertEqual(generate_string(n, k), expected)\n\n"},{"function_name":"merge_sort","header":"def merge_sort(arr):","docstr":"","code":"    # Base case: return if the list is empty or has only one element\n    if len(arr) <= 1:\n        return arr\n\n    # Divide the list into two halves\n    mid = len(arr) \/\/ 2\n    left_half = arr[:mid]\n    right_half = arr[mid:]\n\n    # Recursively sort the left and right halves\n    left_sorted = merge_sort(left_half)\n    right_sorted = merge_sort(right_half)\n\n    # Merge the sorted halves\n    merged = merge(left_sorted, right_sorted)\n\n    return merged\n\ndef merge(left, right):\n    merged = []\n    i = j = 0\n\n    # Merge the two halves while maintaining the sorted order\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            merged.append(left[i])\n            i += 1\n        else:\n            merged.append(right[j])\n            j += 1\n\n    # Append the remaining elements from the left or right half\n    while i < len(left):\n        merged.append(left[i])\n        i += 1\n    while j < len(right):\n        merged.append(right[j])\n        j += 1\n\n    return merged\n","test":"    def test_merge_sort_random_list(self):\n        # Test case with a random list of integers\n        arr = [4, 2, 7, 1, 5, 3, 6]\n        sorted_arr = merge_sort(arr)\n        self.assertEqual(sorted_arr, [1, 2, 3, 4, 5, 6, 7])\n\n    def test_merge_sort_already_sorted_list(self):\n        # Test case with an already sorted list\n        arr = [1, 2, 3, 4, 5]\n        sorted_arr = merge_sort(arr)\n        self.assertEqual(sorted_arr, [1, 2, 3, 4, 5])\n\n    def test_merge_sort_empty_list(self):\n        # Test case with an empty list\n        arr = []\n        sorted_arr = merge_sort(arr)\n        self.assertEqual(sorted_arr, [])\n\n    def test_merge_sort_single_element_list(self):\n        # Test case with a single-element list\n        arr = [5]\n        sorted_arr = merge_sort(arr)\n        self.assertEqual(sorted_arr, [5])\n\n    def test_merge_sort_list_with_duplicates(self):\n        # Test case with a list containing duplicate elements\n        arr = [2, 4, 3, 2, 1, 4, 5, 1]\n        sorted_arr = merge_sort(arr)\n        self.assertEqual(sorted_arr, [1, 1, 2, 2, 3, 4, 4, 5])\n\n"},{"function_name":"find_substrings_with_char","header":"def find_substrings_with_char(string, char):","docstr":"","code":"    substrings = set()\n    length = len(string)\n    for i in range(length):\n        if string[i] == char:\n            for j in range(i, length):\n                substrings.add(string[i:j+1])\n    return sorted(list(substrings))\n","test":"\n    def test_find_substrings_with_char(self):\n        string = \"hello\"\n        char = \"l\"\n        expected_substrings = ['l', 'll', 'llo', 'lo']\n        self.assertEqual(find_substrings_with_char(string, char), expected_substrings)\n\n    def test_find_substrings_with_char_empty_string(self):\n        string = \"\"\n        char = \"a\"\n        expected_substrings = []\n        self.assertEqual(find_substrings_with_char(string, char), expected_substrings)\n\n    def test_find_substrings_with_char_no_match(self):\n        string = \"hello\"\n        char = \"x\"\n        expected_substrings = []\n        self.assertEqual(find_substrings_with_char(string, char), expected_substrings)\n\n    def test_find_substrings_with_char_duplicate_chars(self):\n        string = \"aba\"\n        char = \"a\"\n        expected_substrings = ['a', 'ab', 'aba']\n        self.assertEqual(find_substrings_with_char(string, char), expected_substrings)\n\n"},{"function_name":"merge_strings_by_ascii","header":"def merge_strings_by_ascii(str1, str2):","docstr":"","code":"    merged = []\n    i = 0\n    j = 0\n    while i < len(str1) and j < len(str2):\n        if ord(str1[i]) <= ord(str2[j]):\n            merged.append(str1[i])\n            i += 1\n        else:\n            merged.append(str2[j])\n            j += 1\n    while i < len(str1):\n        merged.append(str1[i])\n        i += 1\n    while j < len(str2):\n        merged.append(str2[j])\n        j += 1\n    return ''.join(merged)\n","test":"\n    def test_merge_strings_by_ascii(self):\n        str1 = \"ace\"\n        str2 = \"bdf\"\n        expected_merged_string = \"abcdef\"\n        self.assertEqual(merge_strings_by_ascii(str1, str2), expected_merged_string)\n\n    def test_merge_strings_by_ascii_empty_strings(self):\n        str1 = \"\"\n        str2 = \"\"\n        expected_merged_string = \"\"\n        self.assertEqual(merge_strings_by_ascii(str1, str2), expected_merged_string)\n\n    def test_merge_strings_by_ascii_one_empty_string(self):\n        str1 = \"abc\"\n        str2 = \"\"\n        expected_merged_string = \"abc\"\n        self.assertEqual(merge_strings_by_ascii(str1, str2), expected_merged_string)\n\n    def test_merge_strings_by_ascii_same_characters(self):\n        str1 = \"abc\"\n        str2 = \"aabbcc\"\n        expected_merged_string = \"aaabbbccc\"\n        self.assertEqual(merge_strings_by_ascii(str1, str2), expected_merged_string)\n\n"},{"function_name":"rotate_matrix","header":"def rotate_matrix(matrix, n):","docstr":"","code":"    rows = len(matrix)\n    cols = len(matrix[0])\n\n    # Normalize n to be within the range [0, 3]\n    n = n % 4\n\n    # Perform rotation\n    for _ in range(n):\n        # Create a new matrix with transposed dimensions\n        new_rows = cols\n        new_cols = rows\n        new_matrix = [[0] * new_cols for _ in range(new_rows)]\n\n        # Fill the new matrix with rotated values\n        for i in range(rows):\n            for j in range(cols):\n                new_matrix[j][new_cols - i - 1] = matrix[i][j]\n\n        # Update the original matrix with the rotated values\n        matrix = new_matrix\n        rows, cols = new_rows, new_cols\n\n    return matrix\n","test":"\n    def test_rotate_matrix_90_degrees(self):\n        matrix = [\n            [1, 2, 3, 4],\n            [5, 6, 7, 8],\n            [9, 10, 11, 12]\n        ]\n        expected_rotated_matrix = [\n            [9, 5, 1],\n            [10, 6, 2],\n            [11, 7, 3],\n            [12, 8, 4]\n        ]\n        self.assertEqual(rotate_matrix(matrix, 1), expected_rotated_matrix)\n\n    def test_rotate_matrix_180_degrees(self):\n        matrix = [\n            [1, 2, 3, 4],\n            [5, 6, 7, 8],\n            [9, 10, 11, 12]\n        ]\n        expected_rotated_matrix = [\n            [12, 11, 10, 9],\n            [8, 7, 6, 5],\n            [4, 3, 2, 1]\n        ]\n        self.assertEqual(rotate_matrix(matrix, 2), expected_rotated_matrix)\n\n    def test_rotate_matrix_270_degrees(self):\n        matrix = [\n            [1, 2, 3, 4],\n            [5, 6, 7, 8],\n            [9, 10, 11, 12]\n        ]\n        expected_rotated_matrix = [\n            [4, 8, 12],\n            [3, 7, 11],\n            [2, 6, 10],\n            [1, 5, 9]\n        ]\n        self.assertEqual(rotate_matrix(matrix, 3), expected_rotated_matrix)\n\n    def test_rotate_matrix_360_degrees(self):\n        matrix = [\n            [1, 2, 3, 4],\n            [5, 6, 7, 8],\n            [9, 10, 11, 12]\n        ]\n        expected_rotated_matrix = matrix\n        self.assertEqual(rotate_matrix(matrix, 4), expected_rotated_matrix)\n\n"},{"function_name":"find_first_repeating_subsequence","header":"def find_first_repeating_subsequence(string):","docstr":"","code":"    n = len(string)\n\n    # Check all possible subsequences of length 3\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                subsequence = string[i] + string[j] + string[k]\n\n                # Check if the subsequence repeats\n                if subsequence in string[k + 1:]:\n                    return subsequence\n\n    return \"\"\n","test":"\n    def test_find_repeating_subsequence(self):\n        # Test case with a repeating subsequence\n        string = \"ababcabade\"\n        expected_subsequence = \"aba\"\n        self.assertEqual(find_first_repeating_subsequence(string), expected_subsequence)\n\n    def test_find_no_repeating_subsequence(self):\n        # Test case with no repeating subsequence\n        string = \"abcdefgh\"\n        expected_subsequence = \"\"\n        self.assertEqual(find_first_repeating_subsequence(string), expected_subsequence)\n\n    def test_find_repeating_subsequence_size_3(self):\n        # Test case with a repeating subsequence of size 3\n        string = \"abcdefgijklabc\"\n        expected_subsequence = \"abc\"\n        self.assertEqual(find_first_repeating_subsequence(string), expected_subsequence)\n\n    def test_find_repeating_subsequence_size_3_simple(self):\n        # Test case with a repeating subsequence of size 3 simple\n        string = \"bacbac\"\n        expected_subsequence = \"bac\"\n        self.assertEqual(find_first_repeating_subsequence(string), expected_subsequence)\n\n"},{"function_name":"is_valid_email","header":"def is_valid_email(email):","docstr":"","code":"    pattern = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9]+\\.[a-zA-Z]{2,}$'\n    return re.match(pattern, email) is not None\n","test":"\n    def test_valid_email(self):\n        valid_emails = [\n            \"example@example.com\",\n            \"john.doe@example.com\",\n            \"jane_doe123@example.com\",\n            \"test123@example123.com\",\n            \"user+name@example.com\",\n            \"user-name@example.com\"\n        ]\n\n        for email in valid_emails:\n            self.assertTrue(is_valid_email(email))\n\n    def test_invalid_email(self):\n        invalid_emails = [\n            \"example@\",\n            \"example.com\",\n            \"user@domain\",\n            \"user@.com\",\n            \"@example.com\",\n            \"user name@example.com\"\n        ]\n\n        for email in invalid_emails:\n            self.assertFalse(is_valid_email(email))\n\n"},{"function_name":"is_substring","header":"def is_substring(substring, string):","docstr":"","code":"    if len(substring) > len(string):\n        return False\n\n    for i in range(len(string) - len(substring) + 1):\n        j = 0\n        while j < len(substring):\n            if string[i+j] != substring[j]:\n                break\n            j += 1\n        if j == len(substring):\n            return True\n\n    return False\n","test":"\n    def test_substring_exists(self):\n        string = \"Hello, world!\"\n        self.assertTrue(is_substring(\"world\", string))\n        self.assertTrue(is_substring(\"Hello\", string))\n        self.assertTrue(is_substring(\"lo, w\", string))\n        self.assertTrue(is_substring(\"!\", string))\n\n    def test_substring_does_not_exist(self):\n        string = \"Hello, world!\"\n        self.assertFalse(is_substring(\"World\", string))\n        self.assertFalse(is_substring(\"hello\", string))\n        self.assertFalse(is_substring(\"lo, w!\", string))\n        self.assertFalse(is_substring(\"foo\", string))\n\n    def test_empty_substring(self):\n        string = \"Hello, world!\"\n        self.assertTrue(is_substring(\"\", string))\n\n    def test_empty_string(self):\n        substring = \"Hello\"\n        self.assertFalse(is_substring(substring, \"\"))\n\n"},{"function_name":"sum_circle_areas","header":"def sum_circle_areas(n):","docstr":"","code":"    total_area = 0\n\n    for radius in range(1, n+1):\n        area = math.pi * radius ** 2\n        total_area += area\n\n    return total_area\n","test":"\n    def test_sum_circle_areas(self):\n        self.assertAlmostEqual(sum_circle_areas(0), 0)\n        self.assertAlmostEqual(sum_circle_areas(1), math.pi)\n        self.assertAlmostEqual(sum_circle_areas(2), math.pi + 4 * math.pi)\n        self.assertAlmostEqual(sum_circle_areas(3), math.pi + 4 * math.pi + 9 * math.pi)\n        self.assertAlmostEqual(sum_circle_areas(5), math.pi + 4 * math.pi + 9 * math.pi + 16 * math.pi + 25 * math.pi)\n\n"},{"function_name":"substring_occurs_twice","header":"def substring_occurs_twice(string, substring):","docstr":"","code":"    pattern = r'\\b' + re.escape(substring) + r'\\b'\n    matches = re.findall(pattern, string)\n    return len(matches) == 2\n","test":"\n    def test_substring_occurs_twice(self):\n        # Test case with substring occurs exactly twice\n        self.assertTrue(substring_occurs_twice(\"Hello, Hello, how are you?\", \"Hello\"))\n\n    def test_substring_less_than_twice(self):\n        # Test case with substring repeated less than twice\n        self.assertFalse(substring_occurs_twice(\"hello, how are you?\", \"hello\"))\n\n    def test_substring_more_than_twice(self):\n        # Test case with substring repeated more than twice\n        self.assertFalse(substring_occurs_twice(\"hello, hello, hello, how are you?\", \"hello\"))\n\n    def test_empty_string(self):\n        # Test case with empty string\n        self.assertFalse(substring_occurs_twice(\"\", \"hello\"))\n\n    def test_empty_substring(self):\n        # Test case with empty substring\n        self.assertFalse(substring_occurs_twice(\"Hello, hello, how are you?\", \"\"))\n\n"},{"function_name":"calculate_knight_moves","header":"def calculate_knight_moves(m, n, x, y):","docstr":"","code":"    # Define the possible knight moves\n    moves = [(-2, -1), (-2, 1), (-1, -2), (-1, 2),\n             (1, -2), (1, 2), (2, -1), (2, 1)]\n\n    # Initialize the count of valid moves\n    count = 0\n\n    # Check each possible move\n    for dx, dy in moves:\n        # Calculate the new position\n        new_x = x + dx\n        new_y = y + dy\n\n        # Check if the new position is within the board bounds\n        if 0 <= new_x < m and 0 <= new_y < n:\n            # Increment the count for a valid move\n            count += 1\n\n    return count\n","test":"\n    def test_knight_moves_3x3(self):\n        # Test case with a 3x3 chess board and knight at position (1, 1)\n        self.assertEqual(calculate_knight_moves(3, 3, 1, 1), 0)\n\n    def test_knight_moves_5x5(self):\n        # Test case with a 5x5 chess board and knight at position (2, 2)\n        self.assertEqual(calculate_knight_moves(5, 5, 2, 2), 8)\n\n    def test_knight_moves_8x8_starting_at_0_0(self):\n        # Test case with a 8x8 chess board and knight at position (0, 0)\n        self.assertEqual(calculate_knight_moves(8, 8, 0, 0), 2)\n\n    def test_knight_moves_8x8_starting_at_7_7(self):\n        # Test case with a 8x8 chess board and knight at position (7, 7)\n        self.assertEqual(calculate_knight_moves(8, 8, 7, 7), 2)\n\n"},{"function_name":"calculate_sum_exceed_index","header":"def calculate_sum_exceed_index(arr, x):","docstr":"","code":"    # Initialize the sum and index\n    total_sum = 0\n    index = 0\n\n    # Iterate over the elements in the list\n    for i, num in enumerate(arr):\n        # Add the current number to the total sum\n        total_sum += num\n\n        # Check if the sum exceeds the given integer x\n        if total_sum > x:\n            index = i\n            break\n\n    # Check if the sum never exceeds x\n    if total_sum <= x:\n        index = len(arr)\n\n    return index\n","test":"\n    def test_sum_exceed_index_case_1(self):\n        # Test case with arr = [1, 3, 5, 7, 9] and x = 12\n        self.assertEqual(calculate_sum_exceed_index([1, 3, 5, 7, 9], 12), 3)\n\n    def test_sum_exceed_index_case_2(self):\n        # Test case with arr = [2, 4, 6, 8, 10] and x = 20\n        self.assertEqual(calculate_sum_exceed_index([2, 4, 6, 8, 10], 20), 4)\n\n    def test_sum_exceed_index_case_3(self):\n        # Test case with arr = [1, 2, 3, 4, 5] and x = 10\n        self.assertEqual(calculate_sum_exceed_index([1, 2, 3, 4, 5], 10), 4)\n\n    def test_sum_exceed_index_case_4(self):\n        # Test case with arr = [1, 2, 3, 4, 5] and x = 100\n        self.assertEqual(calculate_sum_exceed_index([1, 2, 3, 4, 5], 100), 5)\n\n    def test_sum_exceed_index_case_5(self):\n        # Test case with arr = [] and x = 5 (empty list)\n        self.assertEqual(calculate_sum_exceed_index([], 5), 0)\n\n"},{"function_name":"fizz_buzz","header":"def fizz_buzz(x):","docstr":"","code":"    result = []\n    for i in range(1, x + 1):\n        if i % 3 == 0 and i % 5 == 0:\n            result.append(\"FizzBuzz\")\n        elif i % 3 == 0:\n            result.append(\"Fizz\")\n        elif i % 5 == 0:\n            result.append(\"Buzz\")\n        else:\n            result.append(str(i))\n    return result\n","test":"\n    def test_fizz_buzz_case_1(self):\n        # Test case with x = 15\n        expected_output = ['1', '2', 'Fizz', '4', 'Buzz', 'Fizz', '7', '8', 'Fizz', 'Buzz', '11', 'Fizz',\n                           '13', '14', 'FizzBuzz']\n        self.assertEqual(fizz_buzz(15), expected_output)\n\n    def test_fizz_buzz_case_2(self):\n        # Test case with x = 20\n        expected_output = ['1', '2', 'Fizz', '4', 'Buzz', 'Fizz', '7', '8', 'Fizz', 'Buzz', '11', 'Fizz', '13',\n                           '14', 'FizzBuzz', '16', '17', 'Fizz', '19', 'Buzz']\n        self.assertEqual(fizz_buzz(20), expected_output)\n\n    def test_fizz_buzz_case_3(self):\n        # Test case with x = 7\n        expected_output = ['1', '2', 'Fizz', '4', 'Buzz', 'Fizz', '7']\n        self.assertEqual(fizz_buzz(7), expected_output)\n\n    def test_fizz_buzz_case_4(self):\n        # Test case with x = 1\n        expected_output = ['1']\n        self.assertEqual(fizz_buzz(1), expected_output)\n\n"},{"function_name":"validate_parenthesis_brackets_in_string","header":"def validate_parenthesis_brackets_in_string(string):","docstr":"","code":"    stack = []\n\n    for char in string:\n        if char in \"({[\":\n            stack.append(char)\n        elif char in \")}]\":\n            if not stack:\n                return False\n\n            top = stack.pop()\n            if (top == \"(\" and char != \")\") or (top == \"[\" and char != \"]\") or (top == \"{\" and char != \"}\"):\n                return False\n\n    return len(stack) == 0\n","test":"    def test_valid_string(self):\n        # Valid strings with balanced parentheses and brackets\n        self.assertTrue(validate_parenthesis_brackets_in_string(\"\"))\n        self.assertTrue(validate_parenthesis_brackets_in_string(\"()\"))\n        self.assertTrue(validate_parenthesis_brackets_in_string(\"[]\"))\n        self.assertTrue(validate_parenthesis_brackets_in_string(\"()[]\"))\n        self.assertTrue(validate_parenthesis_brackets_in_string(\"([])\"))\n        self.assertTrue(validate_parenthesis_brackets_in_string(\"[()]\"))\n        self.assertTrue(validate_parenthesis_brackets_in_string(\"[()[]]\"))\n\n    def test_invalid_string(self):\n        # Invalid strings with unbalanced parentheses and brackets\n        self.assertFalse(validate_parenthesis_brackets_in_string(\"(\"))\n        self.assertFalse(validate_parenthesis_brackets_in_string(\")\"))\n        self.assertFalse(validate_parenthesis_brackets_in_string(\"[\"))\n        self.assertFalse(validate_parenthesis_brackets_in_string(\"]\"))\n        self.assertFalse(validate_parenthesis_brackets_in_string(\")(\"))\n        self.assertFalse(validate_parenthesis_brackets_in_string(\"(]\"))\n        self.assertFalse(validate_parenthesis_brackets_in_string(\"([)]\"))\n        self.assertFalse(validate_parenthesis_brackets_in_string(\"[(]\"))\n\n    def test_other_characters(self):\n        # Strings with other characters\n        self.assertTrue(validate_parenthesis_brackets_in_string(\"A(B)C[D]E\"))\n        self.assertTrue(validate_parenthesis_brackets_in_string(\"(3 + 2) * [5 - 1]\"))\n        self.assertTrue(validate_parenthesis_brackets_in_string(\"Hello (World) [{Wo}w!]\"))\n        self.assertFalse(validate_parenthesis_brackets_in_string(\"(3 + [2) * {}5 - 1]\"))\n\n    def test_empty_string(self):\n        # Empty string\n        self.assertTrue(validate_parenthesis_brackets_in_string(\"\"))\n\n"},{"function_name":"pascal_triangle","header":"def pascal_triangle(n):","docstr":"","code":"    triangle = []\n    \n    for i in range(n):\n        row = []\n        \n        for j in range(i + 1):\n            if j == 0 or j == i:\n                row.append(1)\n            else:\n                prev_row = triangle[i - 1]\n                num = prev_row[j - 1] + prev_row[j]\n                row.append(num)\n        \n        triangle.append(row)\n    \n    return triangle\n","test":"\n    def test_pascal_triangle(self):\n        # Test case with n = 5\n        n = 5\n        expected_output = [\n            [1],\n            [1, 1],\n            [1, 2, 1],\n            [1, 3, 3, 1],\n            [1, 4, 6, 4, 1]\n        ]\n        self.assertEqual(pascal_triangle(n), expected_output)\n\n    def test_n_equals_0(self):\n        # Test case with n = 0\n        n = 0\n        expected_output = []\n        self.assertEqual(pascal_triangle(n), expected_output)\n\n    def test_n_equals_1(self):\n        # Test case with n = 1\n        n = 1\n        expected_output = [[1]]\n        self.assertEqual(pascal_triangle(n), expected_output)\n\n    def test_n_equals_2(self):\n        # Test case with n = 2\n        n = 2\n        expected_output = [[1], [1, 1]]\n        self.assertEqual(pascal_triangle(n), expected_output)\n\n"},{"function_name":"get_directories_from_path","header":"def get_directories_from_path(path):","docstr":"","code":"    directories = re.findall(r'\\b(\\w+)(?=\/)(?!\\.)', path)\n    return directories\n","test":"\n    def test_get_directories_from_path(self):\n        path = 'path\/to\/some\/file.txt'\n        expected_directories = ['path', 'to', 'some']\n        directories = get_directories_from_path(path)\n        self.assertEqual(directories, expected_directories)\n\n    def test_two_dir(self):\n        path = 'another\/directory\/file.txt'\n        expected_directories = ['another', 'directory']\n        directories = get_directories_from_path(path)\n        self.assertEqual(directories, expected_directories)\n\n    def test_one_dir(self):\n        path = 'root\/file.txt'\n        expected_directories = ['root']\n        directories = get_directories_from_path(path)\n        self.assertEqual(directories, expected_directories)\n\n    def test_no_dirs(self):\n        path = 'file.txt'\n        expected_directories = []\n        directories = get_directories_from_path(path)\n        self.assertEqual(directories, expected_directories)\n    \n    def test_empty_path_string(self):\n        path = ''\n        expected_directories = []\n        directories = get_directories_from_path(path)\n        self.assertEqual(directories, expected_directories)\n\n"},{"function_name":"countdown_strings","header":"def countdown_strings(n):","docstr":"","code":"    result = []\n    for i in range(n):\n        countdown = ' '.join(str(j) for j in range(i + 1, 0, -1))\n        result.append(countdown)\n    return result\n","test":"    def test_countdown_strings(self):\n        # Test case 1\n        result = countdown_strings(5)\n        expected = ['1', '2 1', '3 2 1', '4 3 2 1', '5 4 3 2 1']\n        self.assertEqual(result, expected)\n\n    def test_for_3(self):\n        # Test case 2\n        result = countdown_strings(3)\n        expected = ['1', '2 1', '3 2 1']\n        self.assertEqual(result, expected)\n\n    def test_with_1(self):\n        # Test case 3\n        result = countdown_strings(1)\n        expected = ['1']\n        self.assertEqual(result, expected)\n\n"},{"function_name":"transpose_strings","header":"def transpose_strings(string_list):","docstr":"","code":"    transposed = []\n    for i in range(len(string_list[0])):\n        column = ''.join(string[i] for string in string_list)\n        transposed.append(column)\n    return transposed\n","test":"    def test_strings_len_6(self):\n        # Test case 1\n        input_list = ['runner', 'atomic', 'dry in']\n        expected = ['rad', 'utr', 'noy', 'nm ', 'eii', 'rcn']\n        result = transpose_strings(input_list)\n        self.assertEqual(result, expected)\n\n    def test_strings_len_3(self):\n        # Test case 2\n        input_list = ['abc', 'def', 'ghi']\n        expected = ['adg', 'beh', 'cfi']\n        result = transpose_strings(input_list)\n        self.assertEqual(result, expected)\n\n    def test_empty_strings(self):\n        # Test case 3\n        input_list = ['', '', '']\n        expected = []\n        result = transpose_strings(input_list)\n        self.assertEqual(result, expected)\n\n"},{"function_name":"heapsort","header":"def heapsort(arr):","docstr":"","code":"    def heapify(arr, n, i):\n        largest = i\n        left = 2 * i + 1\n        right = 2 * i + 2\n\n        if left < n and arr[left] > arr[largest]:\n            largest = left\n\n        if right < n and arr[right] > arr[largest]:\n            largest = right\n\n        if largest != i:\n            arr[i], arr[largest] = arr[largest], arr[i]\n            heapify(arr, n, largest)\n\n    n = len(arr)\n\n    # Build max-heap\n    for i in range(n \/\/ 2 - 1, -1, -1):\n        heapify(arr, n, i)\n\n    # Extract elements from the heap one by one\n    for i in range(n - 1, 0, -1):\n        arr[i], arr[0] = arr[0], arr[i]  # Swap\n        heapify(arr, i, 0)\n\n    return arr\n","test":"    def test_heapsort_positive_integers(self):\n        arr = [9, 5, 7, 1, 3]\n        expected_output = [1, 3, 5, 7, 9]\n        self.assertEqual(heapsort(arr), expected_output)\n\n    def test_heapsort_negative_integers(self):\n        arr = [-4, -9, -2, -7, -1]\n        expected_output = [-9, -7, -4, -2, -1]\n        self.assertEqual(heapsort(arr), expected_output)\n\n    def test_heapsort_mixed_integers(self):\n        arr = [-3, 2, -5, 1, 0]\n        expected_output = [-5, -3, 0, 1, 2]\n        self.assertEqual(heapsort(arr), expected_output)\n\n    def test_heapsort_duplicate_elements(self):\n        arr = [4, 1, 4, 2, 3]\n        expected_output = [1, 2, 3, 4, 4]\n        self.assertEqual(heapsort(arr), expected_output)\n\n    def test_heapsort_already_sorted_array(self):\n        arr = [1, 2, 3, 4, 5]\n        expected_output = [1, 2, 3, 4, 5]\n        self.assertEqual(heapsort(arr), expected_output)\n\n    def test_heapsort_empty_array(self):\n        arr = []\n        expected_output = []\n        self.assertEqual(heapsort(arr), expected_output)\n\n    def test_heapsort_single_element_array(self):\n        arr = [42]\n        expected_output = [42]\n        self.assertEqual(heapsort(arr), expected_output)\n\n"},{"function_name":"length_of_each_word","header":"def length_of_each_word(s):","docstr":"","code":"    # Remove leading and trailing spaces\n    s = s.strip()\n\n    # Split the string by spaces\n    words = s.split()\n\n    # Calculate the length of each word\n    word_lengths = [len(word) for word in words]\n\n    return word_lengths\n","test":"    def test_multiple_words(self):\n        s = \"Hello World\"\n        expected_lengths = [5, 5]\n        self.assertEqual(length_of_each_word(s), expected_lengths)\n\n    def test_single_word(self):\n        s = \"Python\"\n        expected_lengths = [6]\n        self.assertEqual(length_of_each_word(s), expected_lengths)\n\n    def test_trailing_spaces(self):\n        s = \"   OpenAI   Language   Model   \"\n        expected_lengths = [6, 8, 5]\n        self.assertEqual(length_of_each_word(s), expected_lengths)\n\n    def test_only_spaces(self):\n        s = \"   \"\n        expected_lengths = []\n        self.assertEqual(length_of_each_word(s), expected_lengths)\n\n    def test_empty_string(self):\n        s = \"\"\n        expected_lengths = []\n        self.assertEqual(length_of_each_word(s), expected_lengths)\n\n"},{"function_name":"min_moves_for_equal_elements","header":"def min_moves_for_equal_elements(nums):","docstr":"","code":"    n = len(nums)\n    if n <= 1:\n        return 0\n\n    # Find the median element\n    median = sorted(nums)[n \/\/ 2]\n\n    # Calculate the total number of moves needed\n    moves = 0\n    for num in nums:\n        moves += abs(num - median)\n\n    return moves\n","test":"\n    def test_min_moves_for_equal_elements_with_increment(self):\n        nums = [1, 2, 3, 4, 5]\n        expected_moves = 6\n        self.assertEqual(min_moves_for_equal_elements(nums), expected_moves)\n\n    def test_min_moves_for_equal_elements_with_decrement(self):\n        nums = [5, 4, 3, 2, 1]\n        expected_moves = 6\n        self.assertEqual(min_moves_for_equal_elements(nums), expected_moves)\n\n    def test_min_moves_for_equal_elements_with_positive_and_negative(self):\n        nums = [-3, -1, 0, 2, 4]\n        expected_moves = 10\n        self.assertEqual(min_moves_for_equal_elements(nums), expected_moves)\n\n    def test_min_moves_for_equal_elements_with_single_element(self):\n        nums = [7]\n        expected_moves = 0\n        self.assertEqual(min_moves_for_equal_elements(nums), expected_moves)\n\n    def test_min_moves_for_equal_elements_with_empty_list(self):\n        nums = []\n        expected_moves = 0\n        self.assertEqual(min_moves_for_equal_elements(nums), expected_moves)\n\n"},{"function_name":"generate_word","header":"def generate_word(s: str) -> str:","docstr":"","code":"    words = s.split()\n    generated_word = ''\n    for i, word in enumerate(words):\n        if len(word) > i:\n            generated_word += word[i]\n    return generated_word\n","test":"    def test_two_words(self):\n        input_str = \"run swim\"\n        expected_output = \"rw\"\n        self.assertEqual(generate_word(input_str), expected_output)\n        \n    def test_three_words(self):\n        input_str = \"apple orange banana\"\n        expected_output = \"arn\"\n        self.assertEqual(generate_word(input_str), expected_output)\n\n    def test_one_words(self):\n        input_str = \"cat\"\n        expected_output = \"c\"\n        self.assertEqual(generate_word(input_str), expected_output)\n\n    def test_empty_string(self):\n        input_str = \"\"\n        expected_output = \"\"\n        self.assertEqual(generate_word(input_str), expected_output)\n\n"},{"function_name":"partition_lists","header":"def partition_lists(nums, x):","docstr":"","code":"    less_than_x = []\n    equal_to_x = []\n    greater_than_x = []\n\n    for num in nums:\n        if num < x:\n            less_than_x.append(num)\n        elif num == x:\n            equal_to_x.append(num)\n        else:\n            greater_than_x.append(num)\n\n    return less_than_x, equal_to_x, greater_than_x\n","test":"    def test_middle_number(self):\n        nums = [4, 2, 5, 1, 3, 6, 2]\n        x = 3\n        expected_result = ([2, 1, 2], [3], [4, 5, 6])\n        result = partition_lists(nums, x)\n        self.assertEqual(result, expected_result)\n\n    def test_all_equal(self):\n        nums = [10, 10, 10, 10]\n        x = 10\n        expected_result = ([], [10, 10, 10, 10], [])\n        result = partition_lists(nums, x)\n        self.assertEqual(result, expected_result)\n\n    def test_all_less(self):\n        nums = [2, 1, 5, 4, 3]\n        x = 6\n        expected_result = ([2, 1, 5, 4, 3], [], [])\n        result = partition_lists(nums, x)\n        self.assertEqual(result, expected_result)\n    \n    def test_all_greater(self):\n        nums = [1, 2, 3, 4, 5]\n        x = 0\n        expected_result = ([], [], [1, 2, 3, 4, 5])\n        result = partition_lists(nums, x)\n        self.assertEqual(result, expected_result)\n\n    def test_empty_list(self):\n        nums = []\n        x = 3\n        expected_result = ([], [], [])\n        result = partition_lists(nums, x)\n        self.assertEqual(result, expected_result)\n\n"},{"function_name":"count_anagram_substring_pairs","header":"def count_anagram_substring_pairs(string):","docstr":"","code":"    # Create a dictionary to store the frequency of substrings\n    substr_freq = {}\n    count = 0\n\n    # Iterate through all possible substrings\n    for i in range(len(string)):\n        for j in range(i + 1, len(string) + 1):\n            # Extract the substring and sort its characters\n            substring = ''.join(sorted(string[i:j]))\n\n            # Increment the count of the corresponding frequency in the dictionary\n            substr_freq[substring] = substr_freq.get(substring, 0) + 1\n\n    # Count the number of pairs of anagram substrings\n    for freq in substr_freq.values():\n        # If there are k occurrences of a substring, there are k*(k-1)\/2 pairs\n        count += freq * (freq - 1) \/\/ 2\n\n    return count\n","test":"\n    def test_no_anagram_substring_pairs(self):\n        string = \"abcd\"\n        expected_count = 0\n        self.assertEqual(count_anagram_substring_pairs(string), expected_count)\n\n    def test_single_anagram_substring_pair(self):\n        string = \"abba\"\n        expected_count = 4\n        self.assertEqual(count_anagram_substring_pairs(string), expected_count)\n\n    def test_multiple_anagram_substring_pairs(self):\n        string = \"abab\"\n        expected_count = 5 \n        self.assertEqual(count_anagram_substring_pairs(string), expected_count)\n\n    def test_repeated_characters(self):\n        string = \"aa\"\n        expected_count = 1\n        self.assertEqual(count_anagram_substring_pairs(string), expected_count)\n\n    def test_empty_string(self):\n        string = \"\"\n        expected_count = 0\n        self.assertEqual(count_anagram_substring_pairs(string), expected_count)\n\n"},{"function_name":"longest_repeating_substring","header":"def longest_repeating_substring(s):","docstr":"","code":"    n = len(s)\n    longest_substring = \"\"\n    \n    for i in range(n):\n        for j in range(i+1, n):\n            substring = \"\"\n            k = 0\n            \n            # Check for repetitions\n            while j+k < n and s[i+k] == s[j+k]:\n                substring += s[i+k]\n                k += 1\n            \n            # Update the longest repeating substring\n            if k > 1 and len(substring) > len(longest_substring):\n                longest_substring = substring\n    \n    return longest_substring\n","test":"    def test_non_empty_string_with_repeating_substring(self):\n        s = \"banana\"\n        expected_result = \"ana\"\n        self.assertEqual(longest_repeating_substring(s), expected_result)\n\n    def test_non_empty_string_with_no_repeating_substring(self):\n        s = \"abcdefg\"\n        expected_result = \"\"\n        self.assertEqual(longest_repeating_substring(s), expected_result)\n\n    def test_empty_string(self):\n        s = \"\"\n        expected_result = \"\"\n        self.assertEqual(longest_repeating_substring(s), expected_result)\n\n    def test_non_empty_string_with_multiple_repeating_substrings(self):\n        s = \"aabbaabbcc\"\n        expected_result = \"aabb\"\n        self.assertEqual(longest_repeating_substring(s), expected_result)\n\n    def test_non_empty_string_with_repeating_substring_at_end(self):\n        s = \"xyzxyzxyz\"\n        expected_result = \"xyzxyz\"\n        self.assertEqual(longest_repeating_substring(s), expected_result)\n\n"},{"function_name":"validate_time_format","header":"def validate_time_format(time_str):","docstr":"","code":"    pattern = r\"^(1[0-2]|[1-9]):[0-5][0-9] (am|pm)$\"\n    return re.match(pattern, time_str) is not None\n","test":"    def test_valid_time_formats(self):\n        self.assertTrue(validate_time_format(\"10:30 am\"))\n        self.assertTrue(validate_time_format(\"9:45 am\"))\n        self.assertTrue(validate_time_format(\"12:00 pm\"))\n        self.assertTrue(validate_time_format(\"1:15 pm\"))\n        self.assertTrue(validate_time_format(\"12:15 am\"))\n\n    def test_invalid_time_formats(self):\n        self.assertFalse(validate_time_format(\"13:00 am\"))\n        self.assertFalse(validate_time_format(\"9:60 pm\"))\n        self.assertFalse(validate_time_format(\"00:00 am\"))\n        self.assertFalse(validate_time_format(\"05:00 pm\"))\n        self.assertFalse(validate_time_format(\"10:30pm\"))\n        self.assertFalse(validate_time_format(\"8:45 PM\"))\n        self.assertFalse(validate_time_format(\"1:15 BM\"))\n\n"},{"function_name":"generate_frequency_dictionary","header":"def generate_frequency_dictionary(string):","docstr":"","code":"    frequency_dict = {}\n    for char in string:\n        if char in frequency_dict:\n            frequency_dict[char] += 1\n        else:\n            frequency_dict[char] = 1\n    return frequency_dict\n","test":"    def test_empty_string(self):\n        string = \"\"\n        expected = {}\n        self.assertEqual(generate_frequency_dictionary(string), expected)\n\n    def test_single_character_string(self):\n        string = \"a\"\n        expected = {\"a\": 1}\n        self.assertEqual(generate_frequency_dictionary(string), expected)\n\n    def test_repeated_characters(self):\n        string = \"abracadabra\"\n        expected = {\"a\": 5, \"b\": 2, \"r\": 2, \"c\": 1, \"d\": 1}\n        self.assertEqual(generate_frequency_dictionary(string), expected)\n\n    def test_unique_characters(self):\n        string = \"xyz123\"\n        expected = {\"x\": 1, \"y\": 1, \"z\": 1, \"1\": 1, \"2\": 1, \"3\": 1}\n        self.assertEqual(generate_frequency_dictionary(string), expected)\n\n"},{"function_name":"remove_non_alpha_words","header":"def remove_non_alpha_words(string):","docstr":"","code":"    words = string.split()\n    rem_lst = [word if re.match(r'^[a-zA-Z]+$', word) else '' for word in words]\n    cleaned_lst = []\n    for i in rem_lst:\n        if i != '':\n            cleaned_lst.append(i)\n    return ' '.join(cleaned_lst)\n","test":"    def test_remove_non_alpha_words_with_mix_of_alpha_and_non_alpha(self):\n        string = \"Hello 123 world! This is a test. with mix123alpha\"\n        expected_output = \"Hello This is a with\"\n        self.assertEqual(remove_non_alpha_words(string), expected_output)\n\n    def test_remove_non_alpha_words_with_alpha_and_numeric(self):\n        string = \"Python programming is fun with numbers 123. Alpha123Numeric\"\n        expected_output = \"Python programming is fun with numbers\"\n        self.assertEqual(remove_non_alpha_words(string), expected_output)\n\n    def test_remove_non_alpha_words_with_hyphen_separated_words(self):\n        string = \"Keep words with hyphen-separated and alpha-numeric 123a456. MixAlpha123Numeric\"\n        expected_output = \"Keep words with and\"\n        self.assertEqual(remove_non_alpha_words(string), expected_output)\n\n    def test_remove_non_alpha_words_with_only_alphabetic_words(self):\n        string = \"Only alphabetic words should remain. MixAlpha123Numeric\"\n        expected_output = \"Only alphabetic words should\"\n        self.assertEqual(remove_non_alpha_words(string), expected_output)\n\n"},{"function_name":"staircase_string","header":"def staircase_string(string):","docstr":"","code":"    length = len(string)\n    out = []\n    for i in range(1, length + 1):\n        out.append(string[:i])\n    return out\n","test":"    def test_create_staircase_with_empty_string(self):\n        string = \"\"\n        expected_output = []\n        self.assertEqual(staircase_string(string), expected_output)\n\n    def test_create_staircase_with_single_character_string(self):\n        string = \"A\"\n        expected_output = [\"A\"]\n        self.assertEqual(staircase_string(string), expected_output)\n\n    def test_create_staircase_with_longer_string(self):\n        string = \"PYTHON\"\n        expected_output = [\n            \"P\",\n            \"PY\",\n            \"PYT\",\n            \"PYTH\",\n            \"PYTHO\",\n            \"PYTHON\"\n        ]\n        self.assertEqual(staircase_string(string), expected_output)\n\n    def test_create_staircase_with_special_characters_and_spaces(self):\n        string = \"!@#$%^&*() \"\n        expected_output = [\n            \"!\",\n            \"!@\",\n            \"!@#\",\n            \"!@#$\",\n            \"!@#$%\",\n            \"!@#$%^\",\n            \"!@#$%^&\",\n            \"!@#$%^&*\",\n            \"!@#$%^&*(\",\n            \"!@#$%^&*()\",\n            \"!@#$%^&*() \"\n        ]\n        self.assertEqual(staircase_string(string), expected_output)\n\n"},{"function_name":"compute_time_difference","header":"def compute_time_difference(time1, time2):","docstr":"","code":"    pattern = r\"(\\d{2}):(\\d{2}):(\\d{2}) ([ap]m)\"\n    match1 = re.match(pattern, time1)\n    match2 = re.match(pattern, time2)\n    \n    hours1 = int(match1.group(1))\n    minutes1 = int(match1.group(2))\n    seconds1 = int(match1.group(3))\n    meridiem1 = match1.group(4)\n    \n    hours2 = int(match2.group(1))\n    minutes2 = int(match2.group(2))\n    seconds2 = int(match2.group(3))\n    meridiem2 = match2.group(4)\n    \n    if meridiem1 == \"pm\" and hours1 != 12:\n        hours1 += 12\n    elif meridiem1 == \"am\" and hours1 == 12:\n        hours1 = 0\n    \n    if meridiem2 == \"pm\" and hours2 != 12:\n        hours2 += 12\n    elif meridiem2 == \"am\" and hours2 == 12:\n        hours2 = 0\n    \n    total_seconds1 = hours1 * 3600 + minutes1 * 60 + seconds1\n    total_seconds2 = hours2 * 3600 + minutes2 * 60 + seconds2\n    \n    if total_seconds1 <= total_seconds2:\n        time_difference = total_seconds2 - total_seconds1\n    else:\n        time_difference = (24 * 3600) - (total_seconds1 - total_seconds2)\n    \n    hours = time_difference \/\/ 3600\n    minutes = (time_difference % 3600) \/\/ 60\n    seconds = time_difference % 60\n    \n    return f\"{hours:02d}:{minutes:02d}:{seconds:02d}\"\n","test":"    def test_compute_time_difference(self):\n        time1 = \"10:30:00 am\"\n        time2 = \"02:45:15 pm\"\n        self.assertEqual(compute_time_difference(time1, time2), \"04:15:15\")\n        \n        time1 = \"11:59:00 pm\"\n        time2 = \"12:01:00 am\"\n        self.assertEqual(compute_time_difference(time1, time2), \"00:02:00\")\n        \n        time1 = \"05:15:45 pm\"\n        time2 = \"05:15:45 pm\"\n        self.assertEqual(compute_time_difference(time1, time2), \"00:00:00\")\n        \n        time1 = \"09:00:00 am\"\n        time2 = \"09:00:30 am\"\n        self.assertEqual(compute_time_difference(time1, time2), \"00:00:30\")\n        \n        time1 = \"12:00:00 pm\"\n        time2 = \"12:00:00 am\"\n        self.assertEqual(compute_time_difference(time1, time2), \"12:00:00\")\n        \n        time1 = \"03:43:23 pm\"\n        time2 = \"03:43:23 pm\"\n        self.assertEqual(compute_time_difference(time1, time2), \"00:00:00\")\n\n"},{"function_name":"swap_characters","header":"def swap_characters(string, i, j):","docstr":"","code":"    if i < 0 or i >= len(string) or j < 0 or j >= len(string):\n        # Invalid indices, return the original string\n        return string\n    \n    # Convert the string to a list to make swapping easier\n    characters = list(string)\n    \n    # Swap the characters at indices i and j\n    characters[i], characters[j] = characters[j], characters[i]\n    \n    # Convert the list back to a string and return it\n    return ''.join(characters)\n","test":"    def test_swap_characters_valid(self):\n        self.assertEqual(swap_characters(\"Hello, World!\", 1, 8), \"Hollo, Werld!\")\n        self.assertEqual(swap_characters(\"Python\", 0, 5), \"nythoP\")\n        self.assertEqual(swap_characters(\"Testing\", 2, 6), \"Tegtins\")\n        self.assertEqual(swap_characters(\"OpenAI\", 3, 4), \"OpeAnI\")\n        \n    def test_swap_invalid_indices(self):\n        self.assertEqual(swap_characters(\"Hello\", -1, 2), \"Hello\")\n        self.assertEqual(swap_characters(\"Python\", 4, 10), \"Python\")\n        self.assertEqual(swap_characters(\"\", 0, 3), \"\")\n        \n    def test_empty_string(self):\n        self.assertEqual(swap_characters(\"\", 0, 0), \"\")\n\n"},{"function_name":"find_kth_largest","header":"def find_kth_largest(nums, k):","docstr":"","code":"    # Sort the array in descending order\n    sorted_nums = sorted(nums, reverse=True)\n    \n    # Return the kth largest element\n    return sorted_nums[k - 1]\n","test":"    def test_find_kth_largest(self):\n        nums = [3, 1, 4, 2, 5]\n        k = 2\n        expected_output = 4\n        self.assertEqual(find_kth_largest(nums, k), expected_output)\n        \n        nums = [9, 8, 7, 6, 5, 4, 3, 2, 1]\n        k = 5\n        expected_output = 5\n        self.assertEqual(find_kth_largest(nums, k), expected_output)\n        \n        nums = [1, 2, 3, 4, 5]\n        k = 1\n        expected_output = 5\n        self.assertEqual(find_kth_largest(nums, k), expected_output)\n        \n        nums = [-1, -5, -2, -3, -4]\n        k = 3\n        expected_output = -3\n        self.assertEqual(find_kth_largest(nums, k), expected_output)\n\n"},{"function_name":"count_primes","header":"def count_primes(n):","docstr":"","code":"    if n <= 2:\n        return 0\n    \n    primes = [True] * n\n    primes[0] = primes[1] = False\n    \n    for i in range(2, int(n ** 0.5) + 1):\n        if primes[i]:\n            primes[i*i:n:i] = [False] * len(primes[i*i:n:i])\n    \n    return sum(primes)\n","test":"    def test_count_primes(self):\n        self.assertEqual(count_primes(10), 4)\n        self.assertEqual(count_primes(20), 8)\n        self.assertEqual(count_primes(30), 10)\n        self.assertEqual(count_primes(50), 15)\n        self.assertEqual(count_primes(100), 25)\n\n"},{"function_name":"h_index","header":"def h_index(citations):","docstr":"","code":"    citations.sort(reverse=True)  # Sort the citations in descending order\n    h = 0\n\n    for i, citation in enumerate(citations):\n        if citation >= i + 1:\n            h = i + 1\n        else:\n            break\n\n    return h\n","test":"    def test_empty_array(self):\n        self.assertEqual(h_index([]), 0)\n\n    def test_single_element_array(self):\n        self.assertEqual(h_index([5]), 1)\n        self.assertEqual(h_index([0]), 0)\n\n    def test_array_with_repeated_citations(self):\n        self.assertEqual(h_index([3, 3, 3, 3, 3]), 3)\n        self.assertEqual(h_index([0, 0, 0, 0, 0]), 0)\n\n    def test_array_with_all_citations_greater_than_array_size(self):\n        self.assertEqual(h_index([10, 12, 15, 8, 7]), 5)\n\n    def test_array_with_all_citations_smaller_than_array_size(self):\n        self.assertEqual(h_index([1, 2, 0, 3, 4]), 2)\n\n    def test_array_with_mix_of_citations(self):\n        self.assertEqual(h_index([10, 8, 5, 4, 3]), 4)\n        self.assertEqual(h_index([6, 5, 3, 1, 0]), 3)\n        self.assertEqual(h_index([25, 8, 5, 3, 3]), 3)\n        self.assertEqual(h_index([0, 1, 2, 3, 4]), 2)\n        self.assertEqual(h_index([3, 0, 6, 1, 5]), 3)\n\n"},{"function_name":"heapify","header":"def heapify(arr, n, i):","docstr":"","code":"    largest = i\n    left = 2 * i + 1\n    right = 2 * i + 2\n\n    if left < n and arr[left] > arr[largest]:\n        largest = left\n\n    if right < n and arr[right] > arr[largest]:\n        largest = right\n\n    if largest != i:\n        arr[i], arr[largest] = arr[largest], arr[i]\n        heapify(arr, n, largest)\n","test":"    def test_heapify(self):\n        # Test case with an unsorted array\n        arr = [4, 10, 3, 5, 1]\n        n = len(arr)\n        i = 0\n\n        heapify(arr, n, i)\n\n        # After heapify, the expected output should be [10, 5, 3, 4, 1]\n        expected_output = [10, 5, 3, 4, 1]\n\n        self.assertEqual(arr, expected_output)\n\n    def test_heapify_already_heap(self):\n        # Test case with an already max heap array\n        arr = [10, 5, 3, 4, 1]\n        n = len(arr)\n        i = 0\n\n        heapify(arr, n, i)\n\n        # The array should remain unchanged\n        expected_output = [10, 5, 3, 4, 1]\n\n        self.assertEqual(arr, expected_output)\n\n    def test_heapify_empty_array(self):\n        # Test case with an empty array\n        arr = []\n        n = len(arr)\n        i = 0\n\n        heapify(arr, n, i)\n\n        # The array should remain empty\n        expected_output = []\n\n        self.assertEqual(arr, expected_output)\n\n    def test_heapify_single_element(self):\n        # Test case with a single-element array\n        arr = [5]\n        n = len(arr)\n        i = 0\n\n        heapify(arr, n, i)\n\n        # The array should remain unchanged\n        expected_output = [5]\n\n        self.assertEqual(arr, expected_output)\n\n"}]}