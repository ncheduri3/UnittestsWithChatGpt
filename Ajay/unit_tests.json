{"function_name":"increasing_triplet","header":"\ndef increasing_triplet(nums):\n","docstr":"","code":"    min_value = float('inf')\n    second_min_value = float('inf')\n    \n    for num in nums:\n        if num <= min_value:\n            min_value = num\n        elif num <= second_min_value:\n            second_min_value = num\n        else:\n            return True\n\n    return False\n","test":"    def test_empty_array(self):\n        self.assertFalse(increasing_triplet([]))\n    \n    def test_single_element_array(self):\n        self.assertFalse(increasing_triplet([5]))\n        self.assertFalse(increasing_triplet([0]))\n    \n    def test_all_equal_elements(self):\n        self.assertFalse(increasing_triplet([3, 3, 3, 3, 3]))\n        self.assertFalse(increasing_triplet([0, 0, 0, 0, 0]))\n    \n    def test_all_increasing_elements(self):\n        self.assertTrue(increasing_triplet([1, 2, 3, 4, 5]))\n    \n    def test_no_triplet_exists(self):\n        self.assertFalse(increasing_triplet([5, 4, 3, 2, 1]))\n    \n    def test_triplet_exists(self):\n        self.assertTrue(increasing_triplet([1, 3, 2, 4, 5]))\n        self.assertTrue(increasing_triplet([5, 2, 4, 1, 3, 7]))\n\n"}
{"function_name":"intersection","header":"from collections import Counter\n\n\ndef intersection(nums1, nums2):\n","docstr":"","code":"    # Count the occurrences of each element in both arrays\n    count1 = Counter(nums1)\n    count2 = Counter(nums2)\n\n    # Find the common elements\n    common_elements = count1.keys() & count2.keys()\n\n    # Create a list containing the common elements repeated the minimum number of times\n    result = []\n    for num in common_elements:\n        count = min(count1[num], count2[num])\n        result.extend([num] * count)\n\n    return sorted(result)\n","test":"    def test_empty_arrays(self):\n        self.assertEqual(intersection([], []), [])\n\n    def test_no_common_elements(self):\n        self.assertEqual(intersection([1, 2, 3], [4, 5, 6]), [])\n        self.assertEqual(intersection([1, 2, 3], [4, 5, 6, 7]), [])\n\n    def test_common_elements(self):\n        self.assertEqual(intersection([1, 2, 2, 1], [2, 2]), [2, 2])\n        self.assertEqual(intersection([4, 9, 5], [9, 4, 9, 8, 4]), [4, 9])\n        self.assertEqual(intersection([1, 2, 2, 1, 1, 3], [2, 1, 1, 4]), [1, 1, 2])\n\n    def test_duplicate_elements(self):\n        self.assertEqual(intersection([1, 2, 2, 1], [2, 2, 2]), [2, 2])\n        self.assertEqual(intersection([1, 2, 2, 1], [2, 2, 1, 1, 1]), [1, 1, 2, 2])\n        self.assertEqual(intersection([1, 2, 2, 1], [1, 1]), [1, 1])\n\n    def test_result_order(self):\n        self.assertEqual(intersection([4, 2, 9, 1, 5], [9, 4, 1, 2, 8, 4]), [1, 2, 4, 9])\n\n"}
{"function_name":"k_smallest_pairs","header":"\ndef k_smallest_pairs(nums1, nums2, k):\n","docstr":"","code":"    pairs = []\n    \n    # Generate all possible pairs (u, v) and their sums\n    for u in nums1:\n        for v in nums2:\n            pairs.append((u + v, u, v))\n    \n    # Sort the pairs based on their sums\n    pairs.sort(key=lambda x: x[0])\n    \n    # Extract the k smallest pairs\n    result = [[u, v] for _, u, v in pairs[:k]]\n    \n    return result\n","test":"    def test_empty_lists(self):\n        nums1 = []\n        nums2 = []\n        k = 3\n        expected_output = []\n        self.assertEqual(k_smallest_pairs(nums1, nums2, k), expected_output)\n\n    def test_single_element_lists(self):\n        nums1 = [1]\n        nums2 = [2]\n        k = 1\n        expected_output = [[1, 2]]\n        self.assertEqual(k_smallest_pairs(nums1, nums2, k), expected_output)\n\n    def test_duplicate_elements(self):\n        nums1 = [1, 1, 2]\n        nums2 = [1, 2, 3]\n        k = 4\n        expected_output = [[1, 1], [1, 1], [1, 2], [1, 2]]\n        self.assertEqual(k_smallest_pairs(nums1, nums2, k), expected_output)\n\n    def test_larger_lists(self):\n        nums1 = [1, 4, 6]\n        nums2 = [2, 3, 5]\n        k = 5\n        expected_output = [[1, 2], [1, 3], [1, 5], [4, 2], [4, 3]]\n        self.assertEqual(k_smallest_pairs(nums1, nums2, k), expected_output)\n\n    def test_k_greater_than_pairs_count(self):\n        nums1 = [1, 2, 3]\n        nums2 = [4, 5, 6]\n        k = 9\n        expected_output = [[1, 4], [1, 5], [2, 4], [1,6], [2,5], [3, 4], [2, 6], [3, 5], [3, 6]]\n        self.assertEqual(k_smallest_pairs(nums1, nums2, k), expected_output)\n\n    def test_empty_result(self):\n        nums1 = [5, 6, 7]\n        nums2 = [1, 2, 3]\n        k = 0\n        expected_output = []\n        self.assertEqual(k_smallest_pairs(nums1, nums2, k), expected_output)\n\n"}
{"function_name":"kth_smallest_in_matrix","header":"\ndef kth_smallest_in_matrix(matrix, k):\n","docstr":"","code":"    m = len(matrix)\n    if m > 0:\n        n = len(matrix[0])\n    else:\n        return None\n\n    if m * n < k:\n        return None\n    \n    # Flatten the matrix into a 1D array\n    flattened = [element for row in matrix for element in row]\n\n    # Sort the flattened array in ascending order\n    flattened.sort()\n\n    # Return the kth smallest element\n    return flattened[k - 1]\n","test":"    def test_kth_smallest_square_matrix(self):\n        matrix = [\n            [1, 3, 5],\n            [2, 4, 6],\n            [7, 8, 9]\n        ]\n        k = 5\n        self.assertEqual(kth_smallest_in_matrix(matrix, k), 5)\n\n    def test_k_bigger_than_matrix_size(self):\n        matrix = [\n            [1, 3, 5],\n            [2, 4, 6],\n            [7, 8, 9]\n        ]\n        k = 10\n        self.assertIsNone(kth_smallest_in_matrix(matrix, k))\n\n    def test_kth_smallest_rectangular_matrix(self):\n        matrix = [\n            [8, 8, 2],\n            [3, 2, 9],\n            [88, 12, 3],\n            [15, 2, 5]\n        ]\n        k = 9\n        self.assertEqual(kth_smallest_in_matrix(matrix, k), 9)\n\n    def test_kth_smallest_single_row_matrix(self):\n        matrix = [[1, 2, 3]]\n        k = 2\n        self.assertEqual(kth_smallest_in_matrix(matrix, k), 2)\n\n    def test_kth_smallest_single_column_matrix(self):\n        matrix = [\n            [1],\n            [2],\n            [3]\n        ]\n        k = 3\n        self.assertEqual(kth_smallest_in_matrix(matrix, k), 3)\n\n    def test_kth_smallest_empty_matrix(self):\n        matrix = []\n        k = 1\n        self.assertIsNone(kth_smallest_in_matrix(matrix, k))\n\n    def test_kth_smallest_single_element_matrix(self):\n        matrix = [[5]]\n        k = 1\n        self.assertEqual(kth_smallest_in_matrix(matrix, k), 5)\n\n"}
{"function_name":"first_duplicate_in_list","header":"\ndef first_duplicate_in_list(lst):\n","docstr":"","code":"    seen = set()\n    for item in lst:\n        if item in seen:\n            return item\n        seen.add(item)\n    return None\n","test":"    def test_duplicate_found(self):\n        lst = [1, 2, 3, 4, 3, 5]\n        self.assertEqual(first_duplicate_in_list(lst), 3)\n\n        lst = ['a', 'b', 'c', 'd', 'c', 'e']\n        self.assertEqual(first_duplicate_in_list(lst), 'c')\n\n        lst = [2.71, 3.14, 1.41, 2.71, 3.14]\n        self.assertEqual(first_duplicate_in_list(lst), 2.71)\n\n    def test_no_duplicate_found(self):\n        lst = [1, 2, 3, 4, 5]\n        self.assertIsNone(first_duplicate_in_list(lst))\n\n        lst = ['a', 'b', 'c', 'd', 'e']\n        self.assertIsNone(first_duplicate_in_list(lst))\n\n        lst = [2.71, 3.14, 1.41]\n        self.assertIsNone(first_duplicate_in_list(lst))\n\n"}
{"function_name":"nth_digit_in_sequence","header":"\ndef nth_digit_in_sequence(n):\n","docstr":"","code":"    if n == 0:\n        return None\n\n    digit_count = 1\n    start_num = 1\n    end_num = 9\n\n    while n > digit_count * (end_num - start_num + 1):\n        n -= digit_count * (end_num - start_num + 1)\n        digit_count += 1\n        start_num *= 10\n        end_num = end_num * 10 + 9\n\n    num = start_num + (n - 1) \/\/ digit_count\n    digit_position = (n - 1) % digit_count\n\n    return int(str(num)[digit_position])\n","test":"    def test_with_n_equal_zero(self):\n        self.assertEqual(nth_digit_in_sequence(0), None)\n        \n    def test_nth_digit_in_sequence(self):\n        self.assertEqual(nth_digit_in_sequence(1), 1)\n        self.assertEqual(nth_digit_in_sequence(2), 2)\n        self.assertEqual(nth_digit_in_sequence(10), 1)\n        self.assertEqual(nth_digit_in_sequence(11), 0)\n        self.assertEqual(nth_digit_in_sequence(12), 1)\n        self.assertEqual(nth_digit_in_sequence(15), 2)\n        self.assertEqual(nth_digit_in_sequence(20), 1)\n        self.assertEqual(nth_digit_in_sequence(21), 5)\n        self.assertEqual(nth_digit_in_sequence(30), 2)\n        self.assertEqual(nth_digit_in_sequence(100), 5)\n        self.assertEqual(nth_digit_in_sequence(500), 0)\n        self.assertEqual(nth_digit_in_sequence(1000), 3)\n\n"}
{"function_name":"cross_product","header":"\ndef cross_product(vector1, vector2):\n","docstr":"","code":"    if len(vector1) != 3 or len(vector2) != 3:\n        raise ValueError(\"Vectors must be of length 3.\")\n\n    result = [\n        vector1[1] * vector2[2] - vector1[2] * vector2[1],\n        vector1[2] * vector2[0] - vector1[0] * vector2[2],\n        vector1[0] * vector2[1] - vector1[1] * vector2[0]\n    ]\n    \n    return result\n","test":"    def test_cross_product_calculation(self):\n        vector1 = [1, 2, 3]\n        vector2 = [4, 5, 6]\n        expected_result = [-3, 6, -3]\n        self.assertEqual(cross_product(vector1, vector2), expected_result)\n\n    def test_invalid_vector_length(self):\n        vector1 = [1, 2, 3, 4]\n        vector2 = [4, 5, 6]\n        self.assertRaises(ValueError, cross_product, vector1, vector2)\n\n        vector1 = [1, 2]\n        vector2 = [4, 5, 6]\n        self.assertRaises(ValueError, cross_product, vector1, vector2)\n\n"}
{"function_name":"fib","header":"\ndef fib(n):  # return Fibonacci series up to n\n","docstr":"","code":"    result = []\n    a, b = 0, 1\n    while b < n:\n        result.append(b)\n        a, b = b, a + b\n    return result\n","test":"\n    def test_fibonacci_sequence(self):\n        n = 10\n        expected_result = [1, 1, 2, 3, 5, 8]\n        self.assertEqual(fib(n), expected_result)\n\n    def test_empty_sequence(self):\n        n = 1\n        expected_result = []\n        self.assertEqual(fib(n), expected_result)\n\n    def test_single_value_sequence(self):\n        n = 2\n        expected_result = [1, 1]\n        self.assertEqual(fib(n), expected_result)\n\n"}
{"function_name":"reverse_string_recursive","header":"\ndef reverse_string_recursive(string):\n","docstr":"","code":"    if len(string) <= 1:\n        return string\n    return reverse_string_recursive(string[1:]) + string[0]\n","test":"\n    def test_reverse_string(self):\n        string = \"Hello, World!\"\n        expected_result = \"!dlroW ,olleH\"\n        self.assertEqual(reverse_string_recursive(string), expected_result)\n\n    def test_empty_string(self):\n        string = \"\"\n        expected_result = \"\"\n        self.assertEqual(reverse_string_recursive(string), expected_result)\n\n    def test_single_character_string(self):\n        string = \"A\"\n        expected_result = \"A\"\n        self.assertEqual(reverse_string_recursive(string), expected_result)\n\n\n"}
{"function_name":"caesar_cipher","header":"\ndef caesar_cipher(string, key):\n","docstr":"","code":"    result = \"\"\n    for char in string:\n        if char.isalpha():\n            ascii_offset = ord('A') if char.isupper() else ord('a')\n            shifted_char = chr((ord(char) - ascii_offset + key) % 26 + ascii_offset)\n            result += shifted_char\n        else:\n            result += char\n    return result\n","test":"\n    def test_caesar_cipher(self):\n        string = \"Hello, World!\"\n        key = 3\n        expected_result = \"Khoor, Zruog!\"\n        self.assertEqual(caesar_cipher(string, key), expected_result)\n\n    def test_empty_string(self):\n        string = \"\"\n        key = 5\n        expected_result = \"\"\n        self.assertEqual(caesar_cipher(string, key), expected_result)\n\n    def test_special_characters(self):\n        string = \"Hello, #123!\"\n        key = 1\n        expected_result = \"Ifmmp, #123!\"\n        self.assertEqual(caesar_cipher(string, key), expected_result)\n\n"}
{"function_name":"indices_of_occurrences","header":"\ndef indices_of_occurrences(string, char):\n","docstr":"","code":"    indices = []\n    for i in range(len(string)):\n        if string[i] == char:\n            indices.append(i)\n    return indices\n","test":"\n    def test_indices_exist(self):\n        string = \"Hello, World!\"\n        char = \"o\"\n        expected_result = [4, 8]\n        self.assertEqual(indices_of_occurrences(string, char), expected_result)\n\n    def test_no_indices_exist(self):\n        string = \"Hello, World!\"\n        char = \"x\"\n        expected_result = []\n        self.assertEqual(indices_of_occurrences(string, char), expected_result)\n\n    def test_empty_string(self):\n        string = \"\"\n        char = \"a\"\n        expected_result = []\n        self.assertEqual(indices_of_occurrences(string, char), expected_result)\n\n    def test_case_sensitive(self):\n        string = \"HelLo, WorLd!\"\n        char = \"L\"\n        expected_result = [3, 10]\n        self.assertEqual(indices_of_occurrences(string, char), expected_result)\n\n"}
{"function_name":"is_arithmetic_sequence","header":"\ndef is_arithmetic_sequence(arr):\n","docstr":"","code":"    if len(arr) <= 2:\n        return True\n\n    diff = arr[1] - arr[0]\n    for i in range(2, len(arr)):\n        if arr[i] - arr[i-1] != diff:\n            return False\n\n    return True\n","test":"    def test_arithmetic_sequence(self):\n        # Test cases with arithmetic sequences\n        self.assertTrue(is_arithmetic_sequence([1, 3, 5, 7, 9]))\n        self.assertTrue(is_arithmetic_sequence([0, 2, 4, 6, 8]))\n        self.assertTrue(is_arithmetic_sequence([-1, -3, -5, -7, -9]))\n        self.assertTrue(is_arithmetic_sequence([5, 5, 5, 5, 5, 5]))\n    \n    def test_arithmetic_by_length(self):\n        self.assertTrue(is_arithmetic_sequence([10]))\n        self.assertTrue(is_arithmetic_sequence([1, 5]))\n        self.assertTrue(is_arithmetic_sequence([]))\n\n    def test_non_arithmetic_sequence(self):\n        # Test cases with non-arithmetic sequences\n        self.assertFalse(is_arithmetic_sequence([1, 3, 6, 10, 15]))\n        self.assertFalse(is_arithmetic_sequence([2, 4, 6, 9, 11]))\n        self.assertFalse(is_arithmetic_sequence([1, 2, 3, 5, 8]))\n\n"}
{"function_name":"reverse_quick_sort","header":"\ndef reverse_quick_sort(arr):\n","docstr":"","code":"    if len(arr) <= 1:\n        return arr\n\n    pivot = arr[len(arr) \/\/ 2]\n    left = [x for x in arr if x > pivot]\n    middle = [x for x in arr if x == pivot]\n    right = [x for x in arr if x < pivot]\n\n    return reverse_quick_sort(left) + middle + reverse_quick_sort(right)\n","test":"\n    def test_reverse_quick_sort(self):\n        arr = [9, 3, 2, 7, 6, 8, 1, 5, 4]\n        expected = [9, 8, 7, 6, 5, 4, 3, 2, 1]\n        self.assertEqual(reverse_quick_sort(arr), expected)\n\n    def test_reverse_quick_sort_empty(self):\n        arr = []\n        expected = []\n        self.assertEqual(reverse_quick_sort(arr), expected)\n\n    def test_reverse_quick_sort_single_element(self):\n        arr = [5]\n        expected = [5]\n        self.assertEqual(reverse_quick_sort(arr), expected)\n\n    def test_reverse_quick_sort_already_sorted(self):\n        arr = [10, 8, 6, 4, 2]\n        expected = [10, 8, 6, 4, 2]\n        self.assertEqual(reverse_quick_sort(arr), expected)\n\n    def test_reverse_quick_sort_duplicate_elements(self):\n        arr = [5, 2, 7, 2, 1, 5]\n        expected = [7, 5, 5, 2, 2, 1]\n        self.assertEqual(reverse_quick_sort(arr), expected)\n\n"}
{"function_name":"find_div_by_a_or_b","header":"\ndef find_div_by_a_or_b(numbers, a, b):\n","docstr":"","code":"    result = []\n    for num in numbers:\n        if (num % a == 0) != (num % b == 0):\n            result.append(num)\n    return result\n","test":"\n    def test_divisible_by_a_or_b(self):\n        numbers = [15, 24, 25, 30, 35, 40, 45, 50]\n        a = 4\n        b = 10\n        expected = [24, 30, 50]\n        self.assertEqual(find_div_by_a_or_b(numbers, a, b), expected)\n\n    def test_no_numbers_divisible(self):\n        numbers = [11, 17, 23, 29, 31, 37]\n        a = 3\n        b = 5\n        expected = []\n        self.assertEqual(find_div_by_a_or_b(numbers, a, b), expected)\n\n    def test_all_numbers_divisible(self):\n        numbers = [10, 20, 30, 40, 50]\n        a = 10\n        b = 5\n        expected = []\n        self.assertEqual(find_div_by_a_or_b(numbers, a, b), expected)\n\n    def test_empty_list(self):\n        numbers = []\n        a = 5\n        b = 10\n        expected = []\n        self.assertEqual(find_div_by_a_or_b(numbers, a, b), expected)\n\n"}
{"function_name":"transpose_matrix","header":"\ndef transpose_matrix(matrix):\n","docstr":"","code":"    rows = len(matrix)\n    if rows == 0:\n        cols = 0\n    else:\n        cols = len(matrix[0])\n\n    transposed = [[0 for _ in range(rows)] for _ in range(cols)]\n\n    for i in range(rows):\n        for j in range(cols):\n            transposed[j][i] = matrix[i][j]\n\n    return transposed\n","test":"\n    def test_transpose_matrix(self):\n        matrix = [[1, 2, 3],\n                  [4, 5, 6],\n                  [7, 8, 9]]\n        expected = [[1, 4, 7],\n                    [2, 5, 8],\n                    [3, 6, 9]]\n        self.assertEqual(transpose_matrix(matrix), expected)\n\n    def test_transpose_empty_matrix(self):\n        matrix = []\n        expected = []\n        self.assertEqual(transpose_matrix(matrix), expected)\n\n    def test_transpose_single_row_matrix(self):\n        matrix = [[1, 2, 3]]\n        expected = [[1], [2], [3]]\n        self.assertEqual(transpose_matrix(matrix), expected)\n\n    def test_transpose_single_column_matrix(self):\n        matrix = [[1], [2], [3]]\n        expected = [[1, 2, 3]]\n        self.assertEqual(transpose_matrix(matrix), expected)\n\n    def test_transpose_rectangular_matrix(self):\n        matrix = [[1, 2, 3],\n                  [4, 5, 6]]\n        expected = [[1, 4],\n                    [2, 5],\n                    [3, 6]]\n        self.assertEqual(transpose_matrix(matrix), expected)\n\n"}
{"function_name":"count_character_occurrences","header":"\ndef count_character_occurrences(string):\n","docstr":"","code":"    counts = {}\n    for char in string:\n        if char in counts:\n            counts[char] += 1\n        else:\n            counts[char] = 1\n    return counts\n","test":"\n    def test_count_character_occurrences(self):\n        string = \"hello\"\n        expected = {'h': 1, 'e': 1, 'l': 2, 'o': 1}\n        self.assertEqual(count_character_occurrences(string), expected)\n\n    def test_count_character_occurrences_empty_string(self):\n        string = \"\"\n        expected = {}\n        self.assertEqual(count_character_occurrences(string), expected)\n\n    def test_count_character_occurrences_repeated_characters(self):\n        string = \"banana\"\n        expected = {'b': 1, 'a': 3, 'n': 2}\n        self.assertEqual(count_character_occurrences(string), expected)\n\n    def test_count_character_occurrences_case_sensitive(self):\n        string = \"Hello\"\n        expected = {'H': 1, 'e': 1, 'l': 2, 'o': 1}\n        self.assertEqual(count_character_occurrences(string), expected)\n\n"}
{"function_name":"generate_string","header":"\ndef generate_string(n, k):\n","docstr":"","code":"    result = \"\"\n    for i in range(n):\n        result += chr(k + i)\n    return result\n","test":"\n    def test_generate_string(self):\n        n = 5\n        k = 65\n        expected = \"ABCDE\"\n        self.assertEqual(generate_string(n, k), expected)\n\n    def test_generate_string_with_empty_input(self):\n        n = 0\n        k = 65\n        expected = \"\"\n        self.assertEqual(generate_string(n, k), expected)\n\n    def test_generate_string_with_negative_n(self):\n        n = -3\n        k = 65\n        expected = \"\"\n        self.assertEqual(generate_string(n, k), expected)\n\n    def test_generate_string_with_zero_k(self):\n        n = 5\n        k = 0\n        expected = \"\\x00\\x01\\x02\\x03\\x04\"\n        self.assertEqual(generate_string(n, k), expected)\n\n"}
{"function_name":"merge_sort","header":"\ndef merge_sort(arr):\n","docstr":"","code":"    # Base case: return if the list is empty or has only one element\n    if len(arr) <= 1:\n        return arr\n\n    # Divide the list into two halves\n    mid = len(arr) \/\/ 2\n    left_half = arr[:mid]\n    right_half = arr[mid:]\n\n    # Recursively sort the left and right halves\n    left_sorted = merge_sort(left_half)\n    right_sorted = merge_sort(right_half)\n\n    # Merge the sorted halves\n    merged = merge(left_sorted, right_sorted)\n\n    return merged\n\ndef merge(left, right):\n    merged = []\n    i = j = 0\n\n    # Merge the two halves while maintaining the sorted order\n    while i < len(left) and j < len(right):\n        if left[i] <= right[j]:\n            merged.append(left[i])\n            i += 1\n        else:\n            merged.append(right[j])\n            j += 1\n\n    # Append the remaining elements from the left or right half\n    while i < len(left):\n        merged.append(left[i])\n        i += 1\n    while j < len(right):\n        merged.append(right[j])\n        j += 1\n\n    return merged\n","test":"    def test_merge_sort_random_list(self):\n        # Test case with a random list of integers\n        arr = [4, 2, 7, 1, 5, 3, 6]\n        sorted_arr = merge_sort(arr)\n        self.assertEqual(sorted_arr, [1, 2, 3, 4, 5, 6, 7])\n\n    def test_merge_sort_already_sorted_list(self):\n        # Test case with an already sorted list\n        arr = [1, 2, 3, 4, 5]\n        sorted_arr = merge_sort(arr)\n        self.assertEqual(sorted_arr, [1, 2, 3, 4, 5])\n\n    def test_merge_sort_empty_list(self):\n        # Test case with an empty list\n        arr = []\n        sorted_arr = merge_sort(arr)\n        self.assertEqual(sorted_arr, [])\n\n    def test_merge_sort_single_element_list(self):\n        # Test case with a single-element list\n        arr = [5]\n        sorted_arr = merge_sort(arr)\n        self.assertEqual(sorted_arr, [5])\n\n    def test_merge_sort_list_with_duplicates(self):\n        # Test case with a list containing duplicate elements\n        arr = [2, 4, 3, 2, 1, 4, 5, 1]\n        sorted_arr = merge_sort(arr)\n        self.assertEqual(sorted_arr, [1, 1, 2, 2, 3, 4, 4, 5])\n\n"}
{"function_name":"find_substrings_with_char","header":"\ndef find_substrings_with_char(string, char):\n","docstr":"","code":"    substrings = set()\n    length = len(string)\n    for i in range(length):\n        if string[i] == char:\n            for j in range(i, length):\n                substrings.add(string[i:j+1])\n    return sorted(list(substrings))\n","test":"\n    def test_find_substrings_with_char(self):\n        string = \"hello\"\n        char = \"l\"\n        expected_substrings = ['l', 'll', 'llo', 'lo']\n        self.assertEqual(find_substrings_with_char(string, char), expected_substrings)\n\n    def test_find_substrings_with_char_empty_string(self):\n        string = \"\"\n        char = \"a\"\n        expected_substrings = []\n        self.assertEqual(find_substrings_with_char(string, char), expected_substrings)\n\n    def test_find_substrings_with_char_no_match(self):\n        string = \"hello\"\n        char = \"x\"\n        expected_substrings = []\n        self.assertEqual(find_substrings_with_char(string, char), expected_substrings)\n\n    def test_find_substrings_with_char_duplicate_chars(self):\n        string = \"aba\"\n        char = \"a\"\n        expected_substrings = ['a', 'ab', 'aba']\n        self.assertEqual(find_substrings_with_char(string, char), expected_substrings)\n\n"}
{"function_name":"merge_strings_by_ascii","header":"\ndef merge_strings_by_ascii(str1, str2):\n","docstr":"","code":"    merged = []\n    i = 0\n    j = 0\n    while i < len(str1) and j < len(str2):\n        if ord(str1[i]) <= ord(str2[j]):\n            merged.append(str1[i])\n            i += 1\n        else:\n            merged.append(str2[j])\n            j += 1\n    while i < len(str1):\n        merged.append(str1[i])\n        i += 1\n    while j < len(str2):\n        merged.append(str2[j])\n        j += 1\n    return ''.join(merged)\n","test":"\n    def test_merge_strings_by_ascii(self):\n        str1 = \"ace\"\n        str2 = \"bdf\"\n        expected_merged_string = \"abcdef\"\n        self.assertEqual(merge_strings_by_ascii(str1, str2), expected_merged_string)\n\n    def test_merge_strings_by_ascii_empty_strings(self):\n        str1 = \"\"\n        str2 = \"\"\n        expected_merged_string = \"\"\n        self.assertEqual(merge_strings_by_ascii(str1, str2), expected_merged_string)\n\n    def test_merge_strings_by_ascii_one_empty_string(self):\n        str1 = \"abc\"\n        str2 = \"\"\n        expected_merged_string = \"abc\"\n        self.assertEqual(merge_strings_by_ascii(str1, str2), expected_merged_string)\n\n    def test_merge_strings_by_ascii_same_characters(self):\n        str1 = \"abc\"\n        str2 = \"aabbcc\"\n        expected_merged_string = \"aaabbbccc\"\n        self.assertEqual(merge_strings_by_ascii(str1, str2), expected_merged_string)\n\n"}
{"function_name":"rotate_matrix","header":"\ndef rotate_matrix(matrix, n):\n","docstr":"","code":"    rows = len(matrix)\n    cols = len(matrix[0])\n\n    # Normalize n to be within the range [0, 3]\n    n = n % 4\n\n    # Perform rotation\n    for _ in range(n):\n        # Create a new matrix with transposed dimensions\n        new_rows = cols\n        new_cols = rows\n        new_matrix = [[0] * new_cols for _ in range(new_rows)]\n\n        # Fill the new matrix with rotated values\n        for i in range(rows):\n            for j in range(cols):\n                new_matrix[j][new_cols - i - 1] = matrix[i][j]\n\n        # Update the original matrix with the rotated values\n        matrix = new_matrix\n        rows, cols = new_rows, new_cols\n\n    return matrix\n","test":"\n    def test_rotate_matrix_90_degrees(self):\n        matrix = [\n            [1, 2, 3, 4],\n            [5, 6, 7, 8],\n            [9, 10, 11, 12]\n        ]\n        expected_rotated_matrix = [\n            [9, 5, 1],\n            [10, 6, 2],\n            [11, 7, 3],\n            [12, 8, 4]\n        ]\n        self.assertEqual(rotate_matrix(matrix, 1), expected_rotated_matrix)\n\n    def test_rotate_matrix_180_degrees(self):\n        matrix = [\n            [1, 2, 3, 4],\n            [5, 6, 7, 8],\n            [9, 10, 11, 12]\n        ]\n        expected_rotated_matrix = [\n            [12, 11, 10, 9],\n            [8, 7, 6, 5],\n            [4, 3, 2, 1]\n        ]\n        self.assertEqual(rotate_matrix(matrix, 2), expected_rotated_matrix)\n\n    def test_rotate_matrix_270_degrees(self):\n        matrix = [\n            [1, 2, 3, 4],\n            [5, 6, 7, 8],\n            [9, 10, 11, 12]\n        ]\n        expected_rotated_matrix = [\n            [4, 8, 12],\n            [3, 7, 11],\n            [2, 6, 10],\n            [1, 5, 9]\n        ]\n        self.assertEqual(rotate_matrix(matrix, 3), expected_rotated_matrix)\n\n    def test_rotate_matrix_360_degrees(self):\n        matrix = [\n            [1, 2, 3, 4],\n            [5, 6, 7, 8],\n            [9, 10, 11, 12]\n        ]\n        expected_rotated_matrix = matrix\n        self.assertEqual(rotate_matrix(matrix, 4), expected_rotated_matrix)\n\n"}
{"function_name":"find_first_repeating_subsequence","header":"\ndef find_first_repeating_subsequence(string):\n","docstr":"","code":"    n = len(string)\n\n    # Check all possible subsequences of length 3\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                subsequence = string[i] + string[j] + string[k]\n\n                # Check if the subsequence repeats\n                if subsequence in string[k + 1:]:\n                    return subsequence\n\n    return \"\"\n","test":"\n    def test_find_repeating_subsequence(self):\n        # Test case with a repeating subsequence\n        string = \"ababcabade\"\n        expected_subsequence = \"aba\"\n        self.assertEqual(find_first_repeating_subsequence(string), expected_subsequence)\n\n    def test_find_no_repeating_subsequence(self):\n        # Test case with no repeating subsequence\n        string = \"abcdefgh\"\n        expected_subsequence = \"\"\n        self.assertEqual(find_first_repeating_subsequence(string), expected_subsequence)\n\n    def test_find_repeating_subsequence_size_3(self):\n        # Test case with a repeating subsequence of size 3\n        string = \"abcdefgijklabc\"\n        expected_subsequence = \"abc\"\n        self.assertEqual(find_first_repeating_subsequence(string), expected_subsequence)\n\n    def test_find_repeating_subsequence_size_3_simple(self):\n        # Test case with a repeating subsequence of size 3 simple\n        string = \"bacbac\"\n        expected_subsequence = \"bac\"\n        self.assertEqual(find_first_repeating_subsequence(string), expected_subsequence)\n\n"}
{"function_name":"is_valid_email","header":"import re\n\n\ndef is_valid_email(email):\n","docstr":"","code":"    pattern = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9]+\\.[a-zA-Z]{2,}$'\n    return re.match(pattern, email) is not None\n","test":"\n    def test_valid_email(self):\n        valid_emails = [\n            \"example@example.com\",\n            \"john.doe@example.com\",\n            \"jane_doe123@example.com\",\n            \"test123@example123.com\",\n            \"user+name@example.com\",\n            \"user-name@example.com\"\n        ]\n\n        for email in valid_emails:\n            self.assertTrue(is_valid_email(email))\n\n    def test_invalid_email(self):\n        invalid_emails = [\n            \"example@\",\n            \"example.com\",\n            \"user@domain\",\n            \"user@.com\",\n            \"@example.com\",\n            \"user name@example.com\"\n        ]\n\n        for email in invalid_emails:\n            self.assertFalse(is_valid_email(email))\n\n"}
{"function_name":"is_substring","header":"\ndef is_substring(substring, string):\n","docstr":"","code":"    if len(substring) > len(string):\n        return False\n\n    for i in range(len(string) - len(substring) + 1):\n        j = 0\n        while j < len(substring):\n            if string[i+j] != substring[j]:\n                break\n            j += 1\n        if j == len(substring):\n            return True\n\n    return False\n","test":"\n    def test_substring_exists(self):\n        string = \"Hello, world!\"\n        self.assertTrue(is_substring(\"world\", string))\n        self.assertTrue(is_substring(\"Hello\", string))\n        self.assertTrue(is_substring(\"lo, w\", string))\n        self.assertTrue(is_substring(\"!\", string))\n\n    def test_substring_does_not_exist(self):\n        string = \"Hello, world!\"\n        self.assertFalse(is_substring(\"World\", string))\n        self.assertFalse(is_substring(\"hello\", string))\n        self.assertFalse(is_substring(\"lo, w!\", string))\n        self.assertFalse(is_substring(\"foo\", string))\n\n    def test_empty_substring(self):\n        string = \"Hello, world!\"\n        self.assertTrue(is_substring(\"\", string))\n\n    def test_empty_string(self):\n        substring = \"Hello\"\n        self.assertFalse(is_substring(substring, \"\"))\n\n"}
{"function_name":"sum_circle_areas","header":"import math\n\n\ndef sum_circle_areas(n):\n","docstr":"","code":"    total_area = 0\n\n    for radius in range(1, n+1):\n        area = math.pi * radius ** 2\n        total_area += area\n\n    return total_area\n","test":"\n    def test_sum_circle_areas(self):\n        self.assertAlmostEqual(sum_circle_areas(0), 0)\n        self.assertAlmostEqual(sum_circle_areas(1), math.pi)\n        self.assertAlmostEqual(sum_circle_areas(2), math.pi + 4 * math.pi)\n        self.assertAlmostEqual(sum_circle_areas(3), math.pi + 4 * math.pi + 9 * math.pi)\n        self.assertAlmostEqual(sum_circle_areas(5), math.pi + 4 * math.pi + 9 * math.pi + 16 * math.pi + 25 * math.pi)\n\n"}
{"function_name":"substring_occurs_twice","header":"import re\n\n\ndef substring_occurs_twice(string, substring):\n","docstr":"","code":"    pattern = r'\\b' + re.escape(substring) + r'\\b'\n    matches = re.findall(pattern, string)\n    return len(matches) == 2\n","test":"\n    def test_substring_occurs_twice(self):\n        # Test case with substring occurs exactly twice\n        self.assertTrue(substring_occurs_twice(\"Hello, Hello, how are you?\", \"Hello\"))\n\n    def test_substring_less_than_twice(self):\n        # Test case with substring repeated less than twice\n        self.assertFalse(substring_occurs_twice(\"hello, how are you?\", \"hello\"))\n\n    def test_substring_more_than_twice(self):\n        # Test case with substring repeated more than twice\n        self.assertFalse(substring_occurs_twice(\"hello, hello, hello, how are you?\", \"hello\"))\n\n    def test_empty_string(self):\n        # Test case with empty string\n        self.assertFalse(substring_occurs_twice(\"\", \"hello\"))\n\n    def test_empty_substring(self):\n        # Test case with empty substring\n        self.assertFalse(substring_occurs_twice(\"Hello, hello, how are you?\", \"\"))\n\n"}
{"function_name":"calculate_knight_moves","header":"\ndef calculate_knight_moves(m, n, x, y):\n","docstr":"","code":"    # Define the possible knight moves\n    moves = [(-2, -1), (-2, 1), (-1, -2), (-1, 2),\n             (1, -2), (1, 2), (2, -1), (2, 1)]\n\n    # Initialize the count of valid moves\n    count = 0\n\n    # Check each possible move\n    for dx, dy in moves:\n        # Calculate the new position\n        new_x = x + dx\n        new_y = y + dy\n\n        # Check if the new position is within the board bounds\n        if 0 <= new_x < m and 0 <= new_y < n:\n            # Increment the count for a valid move\n            count += 1\n\n    return count\n","test":"\n    def test_knight_moves_3x3(self):\n        # Test case with a 3x3 chess board and knight at position (1, 1)\n        self.assertEqual(calculate_knight_moves(3, 3, 1, 1), 0)\n\n    def test_knight_moves_5x5(self):\n        # Test case with a 5x5 chess board and knight at position (2, 2)\n        self.assertEqual(calculate_knight_moves(5, 5, 2, 2), 8)\n\n    def test_knight_moves_8x8_starting_at_0_0(self):\n        # Test case with a 8x8 chess board and knight at position (0, 0)\n        self.assertEqual(calculate_knight_moves(8, 8, 0, 0), 2)\n\n    def test_knight_moves_8x8_starting_at_7_7(self):\n        # Test case with a 8x8 chess board and knight at position (7, 7)\n        self.assertEqual(calculate_knight_moves(8, 8, 7, 7), 2)\n\n"}
{"function_name":"calculate_sum_exceed_index","header":"\ndef calculate_sum_exceed_index(arr, x):\n","docstr":"","code":"    # Initialize the sum and index\n    total_sum = 0\n    index = 0\n\n    # Iterate over the elements in the list\n    for i, num in enumerate(arr):\n        # Add the current number to the total sum\n        total_sum += num\n\n        # Check if the sum exceeds the given integer x\n        if total_sum > x:\n            index = i\n            break\n\n    # Check if the sum never exceeds x\n    if total_sum <= x:\n        index = len(arr)\n\n    return index\n","test":"\n    def test_sum_exceed_index_case_1(self):\n        # Test case with arr = [1, 3, 5, 7, 9] and x = 12\n        self.assertEqual(calculate_sum_exceed_index([1, 3, 5, 7, 9], 12), 3)\n\n    def test_sum_exceed_index_case_2(self):\n        # Test case with arr = [2, 4, 6, 8, 10] and x = 20\n        self.assertEqual(calculate_sum_exceed_index([2, 4, 6, 8, 10], 20), 4)\n\n    def test_sum_exceed_index_case_3(self):\n        # Test case with arr = [1, 2, 3, 4, 5] and x = 10\n        self.assertEqual(calculate_sum_exceed_index([1, 2, 3, 4, 5], 10), 4)\n\n    def test_sum_exceed_index_case_4(self):\n        # Test case with arr = [1, 2, 3, 4, 5] and x = 100\n        self.assertEqual(calculate_sum_exceed_index([1, 2, 3, 4, 5], 100), 5)\n\n    def test_sum_exceed_index_case_5(self):\n        # Test case with arr = [] and x = 5 (empty list)\n        self.assertEqual(calculate_sum_exceed_index([], 5), 0)\n\n"}
{"function_name":"fizz_buzz","header":"\ndef fizz_buzz(x):\n","docstr":"","code":"    result = []\n    for i in range(1, x + 1):\n        if i % 3 == 0 and i % 5 == 0:\n            result.append(\"FizzBuzz\")\n        elif i % 3 == 0:\n            result.append(\"Fizz\")\n        elif i % 5 == 0:\n            result.append(\"Buzz\")\n        else:\n            result.append(str(i))\n    return result\n","test":"\n    def test_fizz_buzz_case_1(self):\n        # Test case with x = 15\n        expected_output = ['1', '2', 'Fizz', '4', 'Buzz', 'Fizz', '7', '8', 'Fizz', 'Buzz', '11', 'Fizz',\n                           '13', '14', 'FizzBuzz']\n        self.assertEqual(fizz_buzz(15), expected_output)\n\n    def test_fizz_buzz_case_2(self):\n        # Test case with x = 20\n        expected_output = ['1', '2', 'Fizz', '4', 'Buzz', 'Fizz', '7', '8', 'Fizz', 'Buzz', '11', 'Fizz', '13',\n                           '14', 'FizzBuzz', '16', '17', 'Fizz', '19', 'Buzz']\n        self.assertEqual(fizz_buzz(20), expected_output)\n\n    def test_fizz_buzz_case_3(self):\n        # Test case with x = 7\n        expected_output = ['1', '2', 'Fizz', '4', 'Buzz', 'Fizz', '7']\n        self.assertEqual(fizz_buzz(7), expected_output)\n\n    def test_fizz_buzz_case_4(self):\n        # Test case with x = 1\n        expected_output = ['1']\n        self.assertEqual(fizz_buzz(1), expected_output)\n\n"}
{"function_name":"validate_parenthesis_brackets_in_string","header":"\ndef validate_parenthesis_brackets_in_string(string):\n","docstr":"","code":"    stack = []\n\n    for char in string:\n        if char in \"({[\":\n            stack.append(char)\n        elif char in \")}]\":\n            if not stack:\n                return False\n\n            top = stack.pop()\n            if (top == \"(\" and char != \")\") or (top == \"[\" and char != \"]\") or (top == \"{\" and char != \"}\"):\n                return False\n\n    return len(stack) == 0\n","test":"    def test_valid_string(self):\n        # Valid strings with balanced parentheses and brackets\n        self.assertTrue(validate_parenthesis_brackets_in_string(\"\"))\n        self.assertTrue(validate_parenthesis_brackets_in_string(\"()\"))\n        self.assertTrue(validate_parenthesis_brackets_in_string(\"[]\"))\n        self.assertTrue(validate_parenthesis_brackets_in_string(\"()[]\"))\n        self.assertTrue(validate_parenthesis_brackets_in_string(\"([])\"))\n        self.assertTrue(validate_parenthesis_brackets_in_string(\"[()]\"))\n        self.assertTrue(validate_parenthesis_brackets_in_string(\"[()[]]\"))\n\n    def test_invalid_string(self):\n        # Invalid strings with unbalanced parentheses and brackets\n        self.assertFalse(validate_parenthesis_brackets_in_string(\"(\"))\n        self.assertFalse(validate_parenthesis_brackets_in_string(\")\"))\n        self.assertFalse(validate_parenthesis_brackets_in_string(\"[\"))\n        self.assertFalse(validate_parenthesis_brackets_in_string(\"]\"))\n        self.assertFalse(validate_parenthesis_brackets_in_string(\")(\"))\n        self.assertFalse(validate_parenthesis_brackets_in_string(\"(]\"))\n        self.assertFalse(validate_parenthesis_brackets_in_string(\"([)]\"))\n        self.assertFalse(validate_parenthesis_brackets_in_string(\"[(]\"))\n\n    def test_other_characters(self):\n        # Strings with other characters\n        self.assertTrue(validate_parenthesis_brackets_in_string(\"A(B)C[D]E\"))\n        self.assertTrue(validate_parenthesis_brackets_in_string(\"(3 + 2) * [5 - 1]\"))\n        self.assertTrue(validate_parenthesis_brackets_in_string(\"Hello (World) [{Wo}w!]\"))\n        self.assertFalse(validate_parenthesis_brackets_in_string(\"(3 + [2) * {}5 - 1]\"))\n\n    def test_empty_string(self):\n        # Empty string\n        self.assertTrue(validate_parenthesis_brackets_in_string(\"\"))\n\n"}
{"function_name":"pascal_triangle","header":"\ndef pascal_triangle(n):\n","docstr":"","code":"    triangle = []\n    \n    for i in range(n):\n        row = []\n        \n        for j in range(i + 1):\n            if j == 0 or j == i:\n                row.append(1)\n            else:\n                prev_row = triangle[i - 1]\n                num = prev_row[j - 1] + prev_row[j]\n                row.append(num)\n        \n        triangle.append(row)\n    \n    return triangle\n","test":"\n    def test_pascal_triangle(self):\n        # Test case with n = 5\n        n = 5\n        expected_output = [\n            [1],\n            [1, 1],\n            [1, 2, 1],\n            [1, 3, 3, 1],\n            [1, 4, 6, 4, 1]\n        ]\n        self.assertEqual(pascal_triangle(n), expected_output)\n\n    def test_n_equals_0(self):\n        # Test case with n = 0\n        n = 0\n        expected_output = []\n        self.assertEqual(pascal_triangle(n), expected_output)\n\n    def test_n_equals_1(self):\n        # Test case with n = 1\n        n = 1\n        expected_output = [[1]]\n        self.assertEqual(pascal_triangle(n), expected_output)\n\n    def test_n_equals_2(self):\n        # Test case with n = 2\n        n = 2\n        expected_output = [[1], [1, 1]]\n        self.assertEqual(pascal_triangle(n), expected_output)\n\n"}
{"function_name":"get_directories_from_path","header":"import re\n\n\ndef get_directories_from_path(path):\n","docstr":"","code":"    directories = re.findall(r'\\b(\\w+)(?=\/)(?!\\.)', path)\n    return directories\n","test":"\n    def test_get_directories_from_path(self):\n        path = 'path\/to\/some\/file.txt'\n        expected_directories = ['path', 'to', 'some']\n        directories = get_directories_from_path(path)\n        self.assertEqual(directories, expected_directories)\n\n    def test_two_dir(self):\n        path = 'another\/directory\/file.txt'\n        expected_directories = ['another', 'directory']\n        directories = get_directories_from_path(path)\n        self.assertEqual(directories, expected_directories)\n\n    def test_one_dir(self):\n        path = 'root\/file.txt'\n        expected_directories = ['root']\n        directories = get_directories_from_path(path)\n        self.assertEqual(directories, expected_directories)\n\n    def test_no_dirs(self):\n        path = 'file.txt'\n        expected_directories = []\n        directories = get_directories_from_path(path)\n        self.assertEqual(directories, expected_directories)\n    \n    def test_empty_path_string(self):\n        path = ''\n        expected_directories = []\n        directories = get_directories_from_path(path)\n        self.assertEqual(directories, expected_directories)\n\n"}
{"function_name":"countdown_strings","header":"\ndef countdown_strings(n):\n","docstr":"","code":"    result = []\n    for i in range(n):\n        countdown = ' '.join(str(j) for j in range(i + 1, 0, -1))\n        result.append(countdown)\n    return result\n","test":"    def test_countdown_strings(self):\n        # Test case 1\n        result = countdown_strings(5)\n        expected = ['1', '2 1', '3 2 1', '4 3 2 1', '5 4 3 2 1']\n        self.assertEqual(result, expected)\n\n    def test_for_3(self):\n        # Test case 2\n        result = countdown_strings(3)\n        expected = ['1', '2 1', '3 2 1']\n        self.assertEqual(result, expected)\n\n    def test_with_1(self):\n        # Test case 3\n        result = countdown_strings(1)\n        expected = ['1']\n        self.assertEqual(result, expected)\n\n"}
{"function_name":"transpose_strings","header":"\ndef transpose_strings(string_list):\n","docstr":"","code":"    transposed = []\n    for i in range(len(string_list[0])):\n        column = ''.join(string[i] for string in string_list)\n        transposed.append(column)\n    return transposed\n","test":"    def test_strings_len_6(self):\n        # Test case 1\n        input_list = ['runner', 'atomic', 'dry in']\n        expected = ['rad', 'utr', 'noy', 'nm ', 'eii', 'rcn']\n        result = transpose_strings(input_list)\n        self.assertEqual(result, expected)\n\n    def test_strings_len_3(self):\n        # Test case 2\n        input_list = ['abc', 'def', 'ghi']\n        expected = ['adg', 'beh', 'cfi']\n        result = transpose_strings(input_list)\n        self.assertEqual(result, expected)\n\n    def test_empty_strings(self):\n        # Test case 3\n        input_list = ['', '', '']\n        expected = []\n        result = transpose_strings(input_list)\n        self.assertEqual(result, expected)\n\n"}
{"function_name":"heapsort","header":"\ndef heapsort(arr):\n","docstr":"","code":"    def heapify(arr, n, i):\n        largest = i\n        left = 2 * i + 1\n        right = 2 * i + 2\n\n        if left < n and arr[left] > arr[largest]:\n            largest = left\n\n        if right < n and arr[right] > arr[largest]:\n            largest = right\n\n        if largest != i:\n            arr[i], arr[largest] = arr[largest], arr[i]\n            heapify(arr, n, largest)\n\n    n = len(arr)\n\n    # Build max-heap\n    for i in range(n \/\/ 2 - 1, -1, -1):\n        heapify(arr, n, i)\n\n    # Extract elements from the heap one by one\n    for i in range(n - 1, 0, -1):\n        arr[i], arr[0] = arr[0], arr[i]  # Swap\n        heapify(arr, i, 0)\n\n    return arr\n","test":"    def test_heapsort_positive_integers(self):\n        arr = [9, 5, 7, 1, 3]\n        expected_output = [1, 3, 5, 7, 9]\n        self.assertEqual(heapsort(arr), expected_output)\n\n    def test_heapsort_negative_integers(self):\n        arr = [-4, -9, -2, -7, -1]\n        expected_output = [-9, -7, -4, -2, -1]\n        self.assertEqual(heapsort(arr), expected_output)\n\n    def test_heapsort_mixed_integers(self):\n        arr = [-3, 2, -5, 1, 0]\n        expected_output = [-5, -3, 0, 1, 2]\n        self.assertEqual(heapsort(arr), expected_output)\n\n    def test_heapsort_duplicate_elements(self):\n        arr = [4, 1, 4, 2, 3]\n        expected_output = [1, 2, 3, 4, 4]\n        self.assertEqual(heapsort(arr), expected_output)\n\n    def test_heapsort_already_sorted_array(self):\n        arr = [1, 2, 3, 4, 5]\n        expected_output = [1, 2, 3, 4, 5]\n        self.assertEqual(heapsort(arr), expected_output)\n\n    def test_heapsort_empty_array(self):\n        arr = []\n        expected_output = []\n        self.assertEqual(heapsort(arr), expected_output)\n\n    def test_heapsort_single_element_array(self):\n        arr = [42]\n        expected_output = [42]\n        self.assertEqual(heapsort(arr), expected_output)\n\n"}
{"function_name":"length_of_each_word","header":"\ndef length_of_each_word(s):\n","docstr":"","code":"    # Remove leading and trailing spaces\n    s = s.strip()\n\n    # Split the string by spaces\n    words = s.split()\n\n    # Calculate the length of each word\n    word_lengths = [len(word) for word in words]\n\n    return word_lengths\n","test":"    def test_multiple_words(self):\n        s = \"Hello World\"\n        expected_lengths = [5, 5]\n        self.assertEqual(length_of_each_word(s), expected_lengths)\n\n    def test_single_word(self):\n        s = \"Python\"\n        expected_lengths = [6]\n        self.assertEqual(length_of_each_word(s), expected_lengths)\n\n    def test_trailing_spaces(self):\n        s = \"   OpenAI   Language   Model   \"\n        expected_lengths = [6, 8, 5]\n        self.assertEqual(length_of_each_word(s), expected_lengths)\n\n    def test_only_spaces(self):\n        s = \"   \"\n        expected_lengths = []\n        self.assertEqual(length_of_each_word(s), expected_lengths)\n\n    def test_empty_string(self):\n        s = \"\"\n        expected_lengths = []\n        self.assertEqual(length_of_each_word(s), expected_lengths)\n\n"}
{"function_name":"min_moves_for_equal_elements","header":"\ndef min_moves_for_equal_elements(nums):\n","docstr":"","code":"    n = len(nums)\n    if n <= 1:\n        return 0\n\n    # Find the median element\n    median = sorted(nums)[n \/\/ 2]\n\n    # Calculate the total number of moves needed\n    moves = 0\n    for num in nums:\n        moves += abs(num - median)\n\n    return moves\n","test":"\n    def test_min_moves_for_equal_elements_with_increment(self):\n        nums = [1, 2, 3, 4, 5]\n        expected_moves = 6\n        self.assertEqual(min_moves_for_equal_elements(nums), expected_moves)\n\n    def test_min_moves_for_equal_elements_with_decrement(self):\n        nums = [5, 4, 3, 2, 1]\n        expected_moves = 6\n        self.assertEqual(min_moves_for_equal_elements(nums), expected_moves)\n\n    def test_min_moves_for_equal_elements_with_positive_and_negative(self):\n        nums = [-3, -1, 0, 2, 4]\n        expected_moves = 10\n        self.assertEqual(min_moves_for_equal_elements(nums), expected_moves)\n\n    def test_min_moves_for_equal_elements_with_single_element(self):\n        nums = [7]\n        expected_moves = 0\n        self.assertEqual(min_moves_for_equal_elements(nums), expected_moves)\n\n    def test_min_moves_for_equal_elements_with_empty_list(self):\n        nums = []\n        expected_moves = 0\n        self.assertEqual(min_moves_for_equal_elements(nums), expected_moves)\n\n"}
{"function_name":"generate_word","header":"\ndef generate_word(s: str) -> str:\n","docstr":"","code":"    words = s.split()\n    generated_word = ''\n    for i, word in enumerate(words):\n        if len(word) > i:\n            generated_word += word[i]\n    return generated_word\n","test":"    def test_two_words(self):\n        input_str = \"run swim\"\n        expected_output = \"rw\"\n        self.assertEqual(generate_word(input_str), expected_output)\n        \n    def test_three_words(self):\n        input_str = \"apple orange banana\"\n        expected_output = \"arn\"\n        self.assertEqual(generate_word(input_str), expected_output)\n\n    def test_one_words(self):\n        input_str = \"cat\"\n        expected_output = \"c\"\n        self.assertEqual(generate_word(input_str), expected_output)\n\n    def test_empty_string(self):\n        input_str = \"\"\n        expected_output = \"\"\n        self.assertEqual(generate_word(input_str), expected_output)\n\n"}
{"function_name":"partition_lists","header":"\ndef partition_lists(nums, x):\n","docstr":"","code":"    less_than_x = []\n    equal_to_x = []\n    greater_than_x = []\n\n    for num in nums:\n        if num < x:\n            less_than_x.append(num)\n        elif num == x:\n            equal_to_x.append(num)\n        else:\n            greater_than_x.append(num)\n\n    return less_than_x, equal_to_x, greater_than_x\n","test":"    def test_middle_number(self):\n        nums = [4, 2, 5, 1, 3, 6, 2]\n        x = 3\n        expected_result = ([2, 1, 2], [3], [4, 5, 6])\n        result = partition_lists(nums, x)\n        self.assertEqual(result, expected_result)\n\n    def test_all_equal(self):\n        nums = [10, 10, 10, 10]\n        x = 10\n        expected_result = ([], [10, 10, 10, 10], [])\n        result = partition_lists(nums, x)\n        self.assertEqual(result, expected_result)\n\n    def test_all_less(self):\n        nums = [2, 1, 5, 4, 3]\n        x = 6\n        expected_result = ([2, 1, 5, 4, 3], [], [])\n        result = partition_lists(nums, x)\n        self.assertEqual(result, expected_result)\n    \n    def test_all_greater(self):\n        nums = [1, 2, 3, 4, 5]\n        x = 0\n        expected_result = ([], [], [1, 2, 3, 4, 5])\n        result = partition_lists(nums, x)\n        self.assertEqual(result, expected_result)\n\n    def test_empty_list(self):\n        nums = []\n        x = 3\n        expected_result = ([], [], [])\n        result = partition_lists(nums, x)\n        self.assertEqual(result, expected_result)\n\n"}
{"function_name":"count_anagram_substring_pairs","header":"\ndef count_anagram_substring_pairs(string):\n","docstr":"","code":"    # Create a dictionary to store the frequency of substrings\n    substr_freq = {}\n    count = 0\n\n    # Iterate through all possible substrings\n    for i in range(len(string)):\n        for j in range(i + 1, len(string) + 1):\n            # Extract the substring and sort its characters\n            substring = ''.join(sorted(string[i:j]))\n\n            # Increment the count of the corresponding frequency in the dictionary\n            substr_freq[substring] = substr_freq.get(substring, 0) + 1\n\n    # Count the number of pairs of anagram substrings\n    for freq in substr_freq.values():\n        # If there are k occurrences of a substring, there are k*(k-1)\/2 pairs\n        count += freq * (freq - 1) \/\/ 2\n\n    return count\n","test":"\n    def test_no_anagram_substring_pairs(self):\n        string = \"abcd\"\n        expected_count = 0\n        self.assertEqual(count_anagram_substring_pairs(string), expected_count)\n\n    def test_single_anagram_substring_pair(self):\n        string = \"abba\"\n        expected_count = 4\n        self.assertEqual(count_anagram_substring_pairs(string), expected_count)\n\n    def test_multiple_anagram_substring_pairs(self):\n        string = \"abab\"\n        expected_count = 5 \n        self.assertEqual(count_anagram_substring_pairs(string), expected_count)\n\n    def test_repeated_characters(self):\n        string = \"aa\"\n        expected_count = 1\n        self.assertEqual(count_anagram_substring_pairs(string), expected_count)\n\n    def test_empty_string(self):\n        string = \"\"\n        expected_count = 0\n        self.assertEqual(count_anagram_substring_pairs(string), expected_count)\n\n"}
{"function_name":"longest_repeating_substring","header":"\ndef longest_repeating_substring(s):\n","docstr":"","code":"    n = len(s)\n    longest_substring = \"\"\n    \n    for i in range(n):\n        for j in range(i+1, n):\n            substring = \"\"\n            k = 0\n            \n            # Check for repetitions\n            while j+k < n and s[i+k] == s[j+k]:\n                substring += s[i+k]\n                k += 1\n            \n            # Update the longest repeating substring\n            if k > 1 and len(substring) > len(longest_substring):\n                longest_substring = substring\n    \n    return longest_substring\n","test":"    def test_non_empty_string_with_repeating_substring(self):\n        s = \"banana\"\n        expected_result = \"ana\"\n        self.assertEqual(longest_repeating_substring(s), expected_result)\n\n    def test_non_empty_string_with_no_repeating_substring(self):\n        s = \"abcdefg\"\n        expected_result = \"\"\n        self.assertEqual(longest_repeating_substring(s), expected_result)\n\n    def test_empty_string(self):\n        s = \"\"\n        expected_result = \"\"\n        self.assertEqual(longest_repeating_substring(s), expected_result)\n\n    def test_non_empty_string_with_multiple_repeating_substrings(self):\n        s = \"aabbaabbcc\"\n        expected_result = \"aabb\"\n        self.assertEqual(longest_repeating_substring(s), expected_result)\n\n    def test_non_empty_string_with_repeating_substring_at_end(self):\n        s = \"xyzxyzxyz\"\n        expected_result = \"xyzxyz\"\n        self.assertEqual(longest_repeating_substring(s), expected_result)\n\n"}
{"function_name":"validate_time_format","header":"import re\n\n\ndef validate_time_format(time_str):\n","docstr":"","code":"    pattern = r\"^(1[0-2]|[1-9]):[0-5][0-9] (am|pm)$\"\n    return re.match(pattern, time_str) is not None\n","test":"    def test_valid_time_formats(self):\n        self.assertTrue(validate_time_format(\"10:30 am\"))\n        self.assertTrue(validate_time_format(\"9:45 am\"))\n        self.assertTrue(validate_time_format(\"12:00 pm\"))\n        self.assertTrue(validate_time_format(\"1:15 pm\"))\n        self.assertTrue(validate_time_format(\"12:15 am\"))\n\n    def test_invalid_time_formats(self):\n        self.assertFalse(validate_time_format(\"13:00 am\"))\n        self.assertFalse(validate_time_format(\"9:60 pm\"))\n        self.assertFalse(validate_time_format(\"00:00 am\"))\n        self.assertFalse(validate_time_format(\"05:00 pm\"))\n        self.assertFalse(validate_time_format(\"10:30pm\"))\n        self.assertFalse(validate_time_format(\"8:45 PM\"))\n        self.assertFalse(validate_time_format(\"1:15 BM\"))\n\n"}
{"function_name":"generate_frequency_dictionary","header":"\ndef generate_frequency_dictionary(string):\n","docstr":"","code":"    frequency_dict = {}\n    for char in string:\n        if char in frequency_dict:\n            frequency_dict[char] += 1\n        else:\n            frequency_dict[char] = 1\n    return frequency_dict\n","test":"    def test_empty_string(self):\n        string = \"\"\n        expected = {}\n        self.assertEqual(generate_frequency_dictionary(string), expected)\n\n    def test_single_character_string(self):\n        string = \"a\"\n        expected = {\"a\": 1}\n        self.assertEqual(generate_frequency_dictionary(string), expected)\n\n    def test_repeated_characters(self):\n        string = \"abracadabra\"\n        expected = {\"a\": 5, \"b\": 2, \"r\": 2, \"c\": 1, \"d\": 1}\n        self.assertEqual(generate_frequency_dictionary(string), expected)\n\n    def test_unique_characters(self):\n        string = \"xyz123\"\n        expected = {\"x\": 1, \"y\": 1, \"z\": 1, \"1\": 1, \"2\": 1, \"3\": 1}\n        self.assertEqual(generate_frequency_dictionary(string), expected)\n\n"}
{"function_name":"remove_non_alpha_words","header":"import re\n\n\ndef remove_non_alpha_words(string):\n","docstr":"","code":"    words = string.split()\n    rem_lst = [word if re.match(r'^[a-zA-Z]+$', word) else '' for word in words]\n    cleaned_lst = []\n    for i in rem_lst:\n        if i != '':\n            cleaned_lst.append(i)\n    return ' '.join(cleaned_lst)\n","test":"    def test_remove_non_alpha_words_with_mix_of_alpha_and_non_alpha(self):\n        string = \"Hello 123 world! This is a test. with mix123alpha\"\n        expected_output = \"Hello This is a with\"\n        self.assertEqual(remove_non_alpha_words(string), expected_output)\n\n    def test_remove_non_alpha_words_with_alpha_and_numeric(self):\n        string = \"Python programming is fun with numbers 123. Alpha123Numeric\"\n        expected_output = \"Python programming is fun with numbers\"\n        self.assertEqual(remove_non_alpha_words(string), expected_output)\n\n    def test_remove_non_alpha_words_with_hyphen_separated_words(self):\n        string = \"Keep words with hyphen-separated and alpha-numeric 123a456. MixAlpha123Numeric\"\n        expected_output = \"Keep words with and\"\n        self.assertEqual(remove_non_alpha_words(string), expected_output)\n\n    def test_remove_non_alpha_words_with_only_alphabetic_words(self):\n        string = \"Only alphabetic words should remain. MixAlpha123Numeric\"\n        expected_output = \"Only alphabetic words should\"\n        self.assertEqual(remove_non_alpha_words(string), expected_output)\n\n"}
{"function_name":"staircase_string","header":"\ndef staircase_string(string):\n","docstr":"","code":"    length = len(string)\n    out = []\n    for i in range(1, length + 1):\n        out.append(string[:i])\n    return out\n","test":"    def test_create_staircase_with_empty_string(self):\n        string = \"\"\n        expected_output = []\n        self.assertEqual(staircase_string(string), expected_output)\n\n    def test_create_staircase_with_single_character_string(self):\n        string = \"A\"\n        expected_output = [\"A\"]\n        self.assertEqual(staircase_string(string), expected_output)\n\n    def test_create_staircase_with_longer_string(self):\n        string = \"PYTHON\"\n        expected_output = [\n            \"P\",\n            \"PY\",\n            \"PYT\",\n            \"PYTH\",\n            \"PYTHO\",\n            \"PYTHON\"\n        ]\n        self.assertEqual(staircase_string(string), expected_output)\n\n    def test_create_staircase_with_special_characters_and_spaces(self):\n        string = \"!@#$%^&*() \"\n        expected_output = [\n            \"!\",\n            \"!@\",\n            \"!@#\",\n            \"!@#$\",\n            \"!@#$%\",\n            \"!@#$%^\",\n            \"!@#$%^&\",\n            \"!@#$%^&*\",\n            \"!@#$%^&*(\",\n            \"!@#$%^&*()\",\n            \"!@#$%^&*() \"\n        ]\n        self.assertEqual(staircase_string(string), expected_output)\n\n"}
{"function_name":"compute_time_difference","header":"import re\n\n\ndef compute_time_difference(time1, time2):\n","docstr":"","code":"    pattern = r\"(\\d{2}):(\\d{2}):(\\d{2}) ([ap]m)\"\n    match1 = re.match(pattern, time1)\n    match2 = re.match(pattern, time2)\n    \n    hours1 = int(match1.group(1))\n    minutes1 = int(match1.group(2))\n    seconds1 = int(match1.group(3))\n    meridiem1 = match1.group(4)\n    \n    hours2 = int(match2.group(1))\n    minutes2 = int(match2.group(2))\n    seconds2 = int(match2.group(3))\n    meridiem2 = match2.group(4)\n    \n    if meridiem1 == \"pm\" and hours1 != 12:\n        hours1 += 12\n    elif meridiem1 == \"am\" and hours1 == 12:\n        hours1 = 0\n    \n    if meridiem2 == \"pm\" and hours2 != 12:\n        hours2 += 12\n    elif meridiem2 == \"am\" and hours2 == 12:\n        hours2 = 0\n    \n    total_seconds1 = hours1 * 3600 + minutes1 * 60 + seconds1\n    total_seconds2 = hours2 * 3600 + minutes2 * 60 + seconds2\n    \n    if total_seconds1 <= total_seconds2:\n        time_difference = total_seconds2 - total_seconds1\n    else:\n        time_difference = (24 * 3600) - (total_seconds1 - total_seconds2)\n    \n    hours = time_difference \/\/ 3600\n    minutes = (time_difference % 3600) \/\/ 60\n    seconds = time_difference % 60\n    \n    return f\"{hours:02d}:{minutes:02d}:{seconds:02d}\"\n","test":"    def test_compute_time_difference(self):\n        time1 = \"10:30:00 am\"\n        time2 = \"02:45:15 pm\"\n        self.assertEqual(compute_time_difference(time1, time2), \"04:15:15\")\n        \n        time1 = \"11:59:00 pm\"\n        time2 = \"12:01:00 am\"\n        self.assertEqual(compute_time_difference(time1, time2), \"00:02:00\")\n        \n        time1 = \"05:15:45 pm\"\n        time2 = \"05:15:45 pm\"\n        self.assertEqual(compute_time_difference(time1, time2), \"00:00:00\")\n        \n        time1 = \"09:00:00 am\"\n        time2 = \"09:00:30 am\"\n        self.assertEqual(compute_time_difference(time1, time2), \"00:00:30\")\n        \n        time1 = \"12:00:00 pm\"\n        time2 = \"12:00:00 am\"\n        self.assertEqual(compute_time_difference(time1, time2), \"12:00:00\")\n        \n        time1 = \"03:43:23 pm\"\n        time2 = \"03:43:23 pm\"\n        self.assertEqual(compute_time_difference(time1, time2), \"00:00:00\")\n\n"}
{"function_name":"swap_characters","header":"\ndef swap_characters(string, i, j):\n","docstr":"","code":"    if i < 0 or i >= len(string) or j < 0 or j >= len(string):\n        # Invalid indices, return the original string\n        return string\n    \n    # Convert the string to a list to make swapping easier\n    characters = list(string)\n    \n    # Swap the characters at indices i and j\n    characters[i], characters[j] = characters[j], characters[i]\n    \n    # Convert the list back to a string and return it\n    return ''.join(characters)\n","test":"    def test_swap_characters_valid(self):\n        self.assertEqual(swap_characters(\"Hello, World!\", 1, 8), \"Hollo, Werld!\")\n        self.assertEqual(swap_characters(\"Python\", 0, 5), \"nythoP\")\n        self.assertEqual(swap_characters(\"Testing\", 2, 6), \"Tegtins\")\n        self.assertEqual(swap_characters(\"OpenAI\", 3, 4), \"OpeAnI\")\n        \n    def test_swap_invalid_indices(self):\n        self.assertEqual(swap_characters(\"Hello\", -1, 2), \"Hello\")\n        self.assertEqual(swap_characters(\"Python\", 4, 10), \"Python\")\n        self.assertEqual(swap_characters(\"\", 0, 3), \"\")\n        \n    def test_empty_string(self):\n        self.assertEqual(swap_characters(\"\", 0, 0), \"\")\n\n"}
{"function_name":"find_kth_largest","header":"\ndef find_kth_largest(nums, k):\n","docstr":"","code":"    # Sort the array in descending order\n    sorted_nums = sorted(nums, reverse=True)\n    \n    # Return the kth largest element\n    return sorted_nums[k - 1]\n","test":"    def test_find_kth_largest(self):\n        nums = [3, 1, 4, 2, 5]\n        k = 2\n        expected_output = 4\n        self.assertEqual(find_kth_largest(nums, k), expected_output)\n        \n        nums = [9, 8, 7, 6, 5, 4, 3, 2, 1]\n        k = 5\n        expected_output = 5\n        self.assertEqual(find_kth_largest(nums, k), expected_output)\n        \n        nums = [1, 2, 3, 4, 5]\n        k = 1\n        expected_output = 5\n        self.assertEqual(find_kth_largest(nums, k), expected_output)\n        \n        nums = [-1, -5, -2, -3, -4]\n        k = 3\n        expected_output = -3\n        self.assertEqual(find_kth_largest(nums, k), expected_output)\n\n"}
{"function_name":"count_primes","header":"\ndef count_primes(n):\n","docstr":"","code":"    if n <= 2:\n        return 0\n    \n    primes = [True] * n\n    primes[0] = primes[1] = False\n    \n    for i in range(2, int(n ** 0.5) + 1):\n        if primes[i]:\n            primes[i*i:n:i] = [False] * len(primes[i*i:n:i])\n    \n    return sum(primes)\n","test":"    def test_count_primes(self):\n        self.assertEqual(count_primes(10), 4)\n        self.assertEqual(count_primes(20), 8)\n        self.assertEqual(count_primes(30), 10)\n        self.assertEqual(count_primes(50), 15)\n        self.assertEqual(count_primes(100), 25)\n\n"}
{"function_name":"h_index","header":"\ndef h_index(citations):\n","docstr":"","code":"    citations.sort(reverse=True)  # Sort the citations in descending order\n    h = 0\n\n    for i, citation in enumerate(citations):\n        if citation >= i + 1:\n            h = i + 1\n        else:\n            break\n\n    return h\n","test":"    def test_empty_array(self):\n        self.assertEqual(h_index([]), 0)\n\n    def test_single_element_array(self):\n        self.assertEqual(h_index([5]), 1)\n        self.assertEqual(h_index([0]), 0)\n\n    def test_array_with_repeated_citations(self):\n        self.assertEqual(h_index([3, 3, 3, 3, 3]), 3)\n        self.assertEqual(h_index([0, 0, 0, 0, 0]), 0)\n\n    def test_array_with_all_citations_greater_than_array_size(self):\n        self.assertEqual(h_index([10, 12, 15, 8, 7]), 5)\n\n    def test_array_with_all_citations_smaller_than_array_size(self):\n        self.assertEqual(h_index([1, 2, 0, 3, 4]), 2)\n\n    def test_array_with_mix_of_citations(self):\n        self.assertEqual(h_index([10, 8, 5, 4, 3]), 4)\n        self.assertEqual(h_index([6, 5, 3, 1, 0]), 3)\n        self.assertEqual(h_index([25, 8, 5, 3, 3]), 3)\n        self.assertEqual(h_index([0, 1, 2, 3, 4]), 2)\n        self.assertEqual(h_index([3, 0, 6, 1, 5]), 3)\n\n"}
{"function_name":"heapify","header":"\ndef heapify(arr, n, i):\n","docstr":"","code":"    largest = i\n    left = 2 * i + 1\n    right = 2 * i + 2\n\n    if left < n and arr[left] > arr[largest]:\n        largest = left\n\n    if right < n and arr[right] > arr[largest]:\n        largest = right\n\n    if largest != i:\n        arr[i], arr[largest] = arr[largest], arr[i]\n        heapify(arr, n, largest)\n","test":"    def test_heapify(self):\n        # Test case with an unsorted array\n        arr = [4, 10, 3, 5, 1]\n        n = len(arr)\n        i = 0\n\n        heapify(arr, n, i)\n\n        # After heapify, the expected output should be [10, 5, 3, 4, 1]\n        expected_output = [10, 5, 3, 4, 1]\n\n        self.assertEqual(arr, expected_output)\n\n    def test_heapify_already_heap(self):\n        # Test case with an already max heap array\n        arr = [10, 5, 3, 4, 1]\n        n = len(arr)\n        i = 0\n\n        heapify(arr, n, i)\n\n        # The array should remain unchanged\n        expected_output = [10, 5, 3, 4, 1]\n\n        self.assertEqual(arr, expected_output)\n\n    def test_heapify_empty_array(self):\n        # Test case with an empty array\n        arr = []\n        n = len(arr)\n        i = 0\n\n        heapify(arr, n, i)\n\n        # The array should remain empty\n        expected_output = []\n\n        self.assertEqual(arr, expected_output)\n\n    def test_heapify_single_element(self):\n        # Test case with a single-element array\n        arr = [5]\n        n = len(arr)\n        i = 0\n\n        heapify(arr, n, i)\n\n        # The array should remain unchanged\n        expected_output = [5]\n\n        self.assertEqual(arr, expected_output)\n\n"}
